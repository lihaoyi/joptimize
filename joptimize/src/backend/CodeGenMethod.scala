package joptimize.backend

import joptimize.{Logger, Util}
import joptimize.analyzer.Namer
import joptimize.model.JType
import joptimize.model.{MethodBody, SSA}
import org.objectweb.asm.Handle
import org.objectweb.asm.Opcodes._
import org.objectweb.asm.tree._
import org.objectweb.asm.util.{Textifier, TraceMethodVisitor}

import scala.collection.mutable

/**
  * Converts the hybrid dataflow/controlflow graph generated by the Walker
  * back into executable bytecode, without all the unreachable, unused or
  * constant-folded instructions
  */

object CodeGenMethod{
  def apply(methodBody: MethodBody,
            allVertices: Set[SSA.Node],
            nodesToBlocks: Map[SSA.Val, SSA.Block],
            cfg: Seq[(SSA.Control, SSA.Control)],
            naming: Namer.Result,
            log: Logger.InferredMethod) = {

    log.pprint(naming)
    val blocksToNodes = nodesToBlocks.groupBy(_._2).map{case (k, v) => (k, v.keys)}
    val sortedControls = sortControlFlowGraph(cfg)

    val blockIndices = sortedControls.zipWithIndex.toMap

    val labels = sortedControls.map(_ -> new LabelNode()).toMap
    val savedLocalNumbers = naming.savedLocals.collect{case (k: SSA.Val, v) => (k, v._1)}
    val blockCode = mutable.Buffer.empty[(Seq[AbstractInsnNode], Option[AbstractInsnNode])]
    for(control <- sortedControls){
//      pprint.log(block)
      val insns = mutable.Buffer.empty[AbstractInsnNode]
      insns.append(labels(control))
      control match{
        case jump: SSA.Jump =>
          val code = generateJumpBytecode(
            jump,
            savedLocalNumbers,
            jumpLabel = { srcBlock =>
              labels(srcBlock.downstreamList.collect{case t: SSA.True => t}.head)
            },
            switchLabels = { srcBlock =>
              (
                labels(srcBlock.downstreamList.collect{case t: SSA.Default => t}.head),
                srcBlock.downstreamList.collect{case t: SSA.Case => t}.map(labels),
              )
            },
            fallthroughLabel = {srcBlock =>
              val destination = srcBlock.downstreamList.collect{case t: SSA.False => t}.head
              if (blockIndices(destination) == blockIndices(control) + 1) None
              else Some(labels(destination))
            }
          )

          insns.appendAll(code)
        case block: SSA.Block =>
          val blockNodes = blocksToNodes.getOrElse(block, Nil).toSeq.sortBy(naming.finalOrderingMap)
          for(node <- blockNodes){
            if (naming.savedLocals.contains(node) && !node.isInstanceOf[SSA.Arg]){
              val nodeInsns =
                if (node.isInstanceOf[SSA.ChangedState]) generateStateChangeBytecode(node, savedLocalNumbers)
                else generateValBytecode(node, savedLocalNumbers)

//              val printer = new Textifier
//              val methodPrinter = new TraceMethodVisitor(printer)
//              pprint.log(node)
//              pprint.log(nodeInsns.map(Renderer.prettyprint(_, printer, methodPrinter)))
              insns.appendAll(nodeInsns)
            }
          }
      }

      val downstreamBlocks = control.downstreamList.collect{case b: SSA.Control => b}

      val footer = downstreamBlocks.toSeq match{
        case Seq(d) if blockIndices(d) != blockIndices(control) + 1 => Some(new JumpInsnNode(GOTO, labels(d)))
        case _ => None
      }

      blockCode.append(insns -> footer)
    }

    naming.savedLocals.keysIterator.foreach{
      case phi: SSA.Phi if phi.getSize != 0 =>
        for((k, v) <- phi.incoming){
          val (insns, footer) = blockCode(blockIndices(k))
          val added = rec(v, savedLocalNumbers) ++ Seq(new VarInsnNode(saveOp(phi), savedLocalNumbers(phi)))
          blockCode(blockIndices(k)) = (insns ++ added, footer)
        }
      case _ => //do nothing
    }


    val finalInsns = new InsnList()
    for((insns, footer) <- blockCode){
      insns.foreach(finalInsns.add)
      footer.foreach(finalInsns.add)
    }

    (blockCode, finalInsns)
  }

  def generateStateChangeBytecode(node: SSA.Val, savedLocalNumbers: Map[SSA.Val, Int]) = {
    node.upstream
      .collect { case v: SSA.Val if !savedLocalNumbers.contains(v) =>
        generateValBytecodeSideEffects(v, savedLocalNumbers)
      }
      .flatten
  }

  def sortControlFlowGraph(cfg: Seq[(SSA.Control, SSA.Control)]) = {
    val predecessor = cfg.groupBy(_._2).map { case (k, v) => (k, v.map(_._1)) }

    val startBlock = cfg
      .flatMap { case (a, b) => Seq(a, b) }
      .find(!predecessor.contains(_))
      .get

    val successor = cfg.groupBy(_._1).map { case (k, v) => (k, v.map(_._2)) }
    val sortedControls = mutable.LinkedHashSet.empty[SSA.Control]

    def sortBlocks(block: SSA.Control): Unit = if (!sortedControls(block)) {
      sortedControls.add(block)
      for (s <- successor.getOrElse(block, Nil)) sortBlocks(s)
    }

    sortBlocks(startBlock)
    sortedControls
  }


  def rec(ssa: SSA.Val, savedLocals: Map[SSA.Val, Int]): Seq[AbstractInsnNode] = {
    if (ssa.isInstanceOf[SSA.ChangedState]) generateStateChangeBytecode(ssa, savedLocals)
    else if (ssa.isInstanceOf[SSA.Phi] && ssa.getSize == 0) Nil
    else if (savedLocals.contains(ssa)) Seq(new VarInsnNode(loadOp(ssa), savedLocals(ssa)))
    else generateValBytecode(ssa, savedLocals)
  }

  def generateJumpBytecode(ssa: SSA.Jump,
                           savedLocals: Map[SSA.Val, Int],
                           jumpLabel: SSA.Control => LabelNode,
                           switchLabels: SSA.Control => (LabelNode, Seq[LabelNode]),
                           fallthroughLabel: SSA.Control => Option[LabelNode]): Seq[AbstractInsnNode] = {
    val upstreams = ssa.upstreamVals.flatMap(rec(_, savedLocals))
    val current: Seq[AbstractInsnNode] = ssa match{
      case n: SSA.UnaBranch =>
        val goto = fallthroughLabel(n).map(new JumpInsnNode(GOTO, _))
        val jump = Seq(new JumpInsnNode(n.opcode.i, jumpLabel(n)))
        jump ++ goto

      case n: SSA.BinBranch =>
        val goto = fallthroughLabel(n).map(new JumpInsnNode(GOTO, _))
        val jump = Seq(new JumpInsnNode(n.opcode.i, jumpLabel(n)))
        jump ++ goto
      case n: SSA.ReturnVal => Seq(new InsnNode(returnOp(n.src)))

      case n: SSA.Return => Seq(new InsnNode(RETURN))
      case n: SSA.AThrow => Seq(new InsnNode(ATHROW))
      case n: SSA.TableSwitch =>
        val (default, labels) = switchLabels(n)
        Seq(new TableSwitchInsnNode(n.min, n.max, default, labels.toArray:_*))
      case n: SSA.LookupSwitch =>
        val (default, labels) = switchLabels(n)
        Seq(new LookupSwitchInsnNode(default, n.keys.toArray, labels.toArray))
    }

    upstreams ++ current

  }

  def generateValBytecode(ssa: SSA.Val, savedLocals: Map[SSA.Val, Int]): Seq[AbstractInsnNode] = {
    if (ssa.isInstanceOf[SSA.Phi]) Nil
    else {
      val upstreams = ssa.upstreamVals.flatMap(rec(_, savedLocals))
      val current: Seq[AbstractInsnNode] = ssa match{
        case _: SSA.ChangedState => Nil
        case _: SSA.Copy => Nil

        case _: SSA.Phi => Nil
        case n: SSA.Arg => Nil
        case n: SSA.BinOp => Seq(new InsnNode(n.opcode.i))
        case n: SSA.UnaOp => Seq(new InsnNode(n.opcode.i))
        case n: SSA.CheckCast => Seq(new TypeInsnNode(CHECKCAST, n.desc.name))
        case n: SSA.ArrayLength => Seq(new InsnNode(ARRAYLENGTH))
        case n: SSA.InstanceOf => Seq(new TypeInsnNode(INSTANCEOF, n.desc.name))
        case n: SSA.ConstI => Seq(n.value match{
          case -1 => new InsnNode(ICONST_M1)
          case 0 => new InsnNode(ICONST_0)
          case 1 => new InsnNode(ICONST_1)
          case 2 => new InsnNode(ICONST_2)
          case 3 => new InsnNode(ICONST_3)
          case 4 => new InsnNode(ICONST_4)
          case 5 => new InsnNode(ICONST_5)
          case _ =>
            if (-128 <= n.value && n.value < 127) new IntInsnNode(BIPUSH, n.value)
            else if (-32768 <= n.value && n.value <= 32767) new IntInsnNode(SIPUSH, n.value)
            else new LdcInsnNode(n.value)
        })
        case n: SSA.ConstJ => Seq(n.value match{
          case 0 => new InsnNode(LCONST_0)
          case 1 => new InsnNode(LCONST_1)
          case _ => new LdcInsnNode(n.value)
        })
        case n: SSA.ConstF => Seq(n.value match{
          case 0 => new InsnNode(FCONST_0)
          case 1 => new InsnNode(FCONST_1)
          case 2 => new InsnNode(FCONST_2)
          case _ => new LdcInsnNode(n.value)
        })
        case n: SSA.ConstD => Seq(n.value match{
          case 0 => new InsnNode(DCONST_0)
          case 1 => new InsnNode(DCONST_1)
          case _ => new LdcInsnNode(n.value)
        })
        case n: SSA.ConstStr => Seq(new LdcInsnNode(n.value))
        case n: SSA.ConstNull => Seq(new InsnNode(ACONST_NULL))
        case n: SSA.ConstCls =>
          Seq(new LdcInsnNode(org.objectweb.asm.Type.getObjectType(n.value.name)))
        case n: SSA.InvokeStatic =>
          Seq(new MethodInsnNode(INVOKESTATIC, n.cls.name, n.name, n.desc.unparse))
        case n: SSA.InvokeSpecial =>
          Seq(new MethodInsnNode(INVOKESPECIAL, n.cls.name, n.name, n.desc.unparse))
        case n: SSA.InvokeVirtual =>
          Seq(new MethodInsnNode(INVOKEVIRTUAL, n.cls.name, n.name, n.desc.unparse))
        case n: SSA.InvokeInterface =>
          Seq(new MethodInsnNode(INVOKEINTERFACE, n.cls.name, n.name, n.desc.unparse))
        case n: SSA.InvokeDynamic=>
          Seq(new InvokeDynamicInsnNode(
            n.name, n.desc.unparse,
            new Handle(n.bootstrap.tag, n.bootstrap.owner.name, n.bootstrap.name, n.bootstrap.desc.unparse),
            n.bootstrapArgs.map(SSA.InvokeDynamic.argToAny):_*
          ))
        case n: SSA.New => Seq(new TypeInsnNode(NEW, n.cls.name))
        case n: SSA.NewArray => Seq(newArrayOp(n.typeRef))
        case n: SSA.MultiANewArray => Seq(new MultiANewArrayInsnNode(n.desc.name, n.dims.length))
        case n: SSA.PutStatic => Seq(new FieldInsnNode(PUTSTATIC, n.cls.name, n.name, n.desc.internalName))
        case n: SSA.GetStatic => Seq(new FieldInsnNode(GETSTATIC, n.cls.name, n.name, n.desc.internalName))
        case n: SSA.PutField => Seq(new FieldInsnNode(PUTFIELD, n.owner.name, n.name, n.desc.internalName))
        case n: SSA.GetField => Seq(new FieldInsnNode(GETFIELD, n.owner.name, n.name, n.desc.internalName))
        case n: SSA.PutArray => Seq(new InsnNode(arrayStoreOp(n.src)))
        case n: SSA.GetArray => Seq(new InsnNode(arrayLoadOp(n.tpe)))
        case n: SSA.MonitorEnter => ???
        case n: SSA.MonitorExit => ???
      }

      val save = ssa match{
        case n: SSA.Val if savedLocals.contains(n) && n.getSize > 0 =>
          Seq(new VarInsnNode(saveOp(n), savedLocals(n)))
        case _ => Nil
      }

      upstreams ++ current ++ save

    }
  }


  def generateValBytecodeSideEffects(ssa: SSA.Val, savedLocals: Map[SSA.Val, Int]): Seq[AbstractInsnNode] = {
    if (ssa.isInstanceOf[SSA.Phi]) Nil
    else {
      val upstreams = ssa.upstreamVals.flatMap(rec(_, savedLocals))
      val current: Seq[AbstractInsnNode] = ssa match{
        case _: SSA.State | _: SSA.Copy | _: SSA.Phi | _: SSA.Arg => Nil
        case n: SSA.BinOp => Seq(new InsnNode(n.opcode.i), new InsnNode(POP))
        case n: SSA.UnaOp => Seq(new InsnNode(n.opcode.i), new InsnNode(POP))
        case n: SSA.CheckCast => Seq(new TypeInsnNode(CHECKCAST, n.desc.name), new InsnNode(POP))
        case n: SSA.ArrayLength => Seq(new InsnNode(ARRAYLENGTH), new InsnNode(POP))
        case n: SSA.InstanceOf => Seq(new TypeInsnNode(INSTANCEOF, n.desc.name), new InsnNode(POP))
        case _: SSA.ConstI | _: SSA.ConstJ | _: SSA.ConstF | _: SSA.ConstD |
             _: SSA.ConstStr | _: SSA.ConstNull | _: SSA.ConstCls  => Nil

        case n: SSA.InvokeStatic =>
          Seq(new MethodInsnNode(INVOKESTATIC, n.cls.name, n.name, n.desc.unparse)) ++
          (if (n.desc.ret.size == 0) Nil else Seq(new InsnNode(POP)))
        case n: SSA.InvokeSpecial =>
          Seq(new MethodInsnNode(INVOKESPECIAL, n.cls.name, n.name, n.desc.unparse)) ++
          (if (n.desc.ret.size == 0) Nil else Seq(new InsnNode(POP)))
        case n: SSA.InvokeVirtual =>
          Seq(new MethodInsnNode(INVOKEVIRTUAL, n.cls.name, n.name, n.desc.unparse)) ++
          (if (n.desc.ret.size == 0) Nil else Seq(new InsnNode(POP)))
        case n: SSA.InvokeInterface =>
          Seq(new MethodInsnNode(INVOKEINTERFACE, n.cls.name, n.name, n.desc.unparse)) ++
          (if (n.desc.ret.size == 0) Nil else Seq(new InsnNode(POP)))
        case n: SSA.InvokeDynamic =>
          Seq(new InvokeDynamicInsnNode(
            n.name, n.desc.unparse,
            new Handle(n.bootstrap.tag, n.bootstrap.owner.name, n.bootstrap.name, n.bootstrap.desc.unparse),
            n.bootstrapArgs.map(SSA.InvokeDynamic.argToAny):_*
          ))
        case n: SSA.New => ???
        case n: SSA.NewArray => Seq(newArrayOp(n.typeRef), new InsnNode(POP))
        case n: SSA.MultiANewArray => Seq(new MultiANewArrayInsnNode(n.desc.name, n.dims.length), new InsnNode(POP))
        case n: SSA.PutStatic => Seq(new FieldInsnNode(PUTSTATIC, n.cls.name, n.name, n.desc.internalName))
        case n: SSA.GetStatic => Seq(new FieldInsnNode(GETSTATIC, n.cls.name, n.name, n.desc.internalName), new InsnNode(POP))
        case n: SSA.PutField => Seq(new FieldInsnNode(PUTFIELD, n.owner.name, n.name, n.desc.internalName))
        case n: SSA.GetField => Seq(new FieldInsnNode(GETFIELD, n.owner.name, n.name, n.desc.internalName), new InsnNode(POP))
        case n: SSA.PutArray => Seq(new InsnNode(arrayStoreOp(n.src)))
        case n: SSA.GetArray => Seq(new InsnNode(arrayLoadOp(n.tpe)), new InsnNode(POP))
        case n: SSA.MonitorEnter => ???
        case n: SSA.MonitorExit => ???
      }

      upstreams ++ current

    }
  }

  def newArrayOp(typeRef: JType) = {
    typeRef match {
      case JType.Prim.Z => new IntInsnNode(NEWARRAY, T_BOOLEAN)
      case JType.Prim.C => new IntInsnNode(NEWARRAY, T_CHAR)
      case JType.Prim.B => new IntInsnNode(NEWARRAY, T_BYTE)
      case JType.Prim.S => new IntInsnNode(NEWARRAY, T_SHORT)
      case JType.Prim.I => new IntInsnNode(NEWARRAY, T_INT)
      case JType.Prim.F => new IntInsnNode(NEWARRAY, T_FLOAT)
      case JType.Prim.D => new IntInsnNode(NEWARRAY, T_DOUBLE)
      case JType.Prim.J => new IntInsnNode(NEWARRAY, T_LONG)
      case t => new TypeInsnNode(ANEWARRAY, t.name)
    }
  }

  def arrayStoreOp(src: SSA.Val) = {
    src.jtype match {
      case JType.Prim.Z => IASTORE
      case JType.Prim.C => CASTORE
      case JType.Prim.B => BASTORE
      case JType.Prim.S => SASTORE
      case JType.Prim.I => IASTORE
      case JType.Prim.F => FASTORE
      case JType.Prim.D => DASTORE
      case JType.Prim.J => LASTORE
      case t => AASTORE
    }
  }

  def arrayLoadOp(tpe: JType) = {
    tpe match {
      case JType.Prim.Z => IALOAD
      case JType.Prim.C => CALOAD
      case JType.Prim.B => BALOAD
      case JType.Prim.S => SALOAD
      case JType.Prim.I => IALOAD
      case JType.Prim.F => FALOAD
      case JType.Prim.D => DALOAD
      case JType.Prim.J => LALOAD
      case t => AALOAD
    }
  }

  def loadOp(ssa: SSA.Val) = {
    ssa.jtype match {
      case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => ILOAD
      case JType.Prim.J => LLOAD
      case JType.Prim.F => FLOAD
      case JType.Prim.D => DLOAD
      case _ => ALOAD
    }
  }

  def saveOp(n: SSA.Val) = {
    n.jtype match {
      case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => ISTORE
      case JType.Prim.J => LSTORE
      case JType.Prim.F => FSTORE
      case JType.Prim.D => DSTORE
      case _ => ASTORE
    }
  }

  def returnOp(a: SSA.Val) = {
    a.jtype match {
      case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => IRETURN
      case JType.Prim.J => LRETURN
      case JType.Prim.F => FRETURN
      case JType.Prim.D => DRETURN
      case _ => ARETURN
    }
  }
}
