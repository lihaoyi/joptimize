package joptimize

import org.objectweb.asm.Opcodes
import org.objectweb.asm.tree._

import collection.JavaConverters._
import scala.collection.mutable

/**
  * Converts the hybrid dataflow/controlflow graph generated by the Walker
  * back into executable bytecode, without all the unreachable, unused or
  * constant-folded instructions
  */
object Liveness {

  def apply(allVisitedBlocks: Seq[Walker.BlockResult],
            merges: Seq[(Frame[SSA], Frame[SSA])]): (InsnList, Set[Int]) = {
    val allTerminals = allVisitedBlocks.flatMap(_.terminalInsns)
    val subCallArgLiveness = allVisitedBlocks.flatMap(_.subCallArgLiveness).toMap
    val mergeLookup = mutable.Map.empty[SSA, mutable.Buffer[SSA]]

    for((lhs, rhs) <- merges){
      lhs.zipForeach(rhs){(l, r) =>
        mergeLookup.getOrElseUpdate(l, mutable.Buffer()) += r
      }
    }

    pprint.log(allTerminals)
    pprint.log(allVisitedBlocks.map(_.blockInsns))
//    def getMerges(l: SSA) = mergeLookup.getOrElse(l, Nil)
//
//    val allLiveInsns =
//      allVertices.collect{case Left(lv) => lv.insn}.collect{case Right(mn) => mn} ++
//      allTerminals.map(_.insn)
//
//    val liveArgumentIndices = roots
//      .collect{case Left(lv) => lv.insn}
//      .collect{case Left(n) => n}
//
//    val labelsToBlocks = allVisitedBlocks.flatMap(b => b.leadingLabel -> b).toMap
//
//    liveArgumentIndices
    ???
  }
}


