package joptimize.analysis


import joptimize.model.JType

import joptimize.graph.{HavlakLoopTree, LengauerTarjanDominatorTree}
import joptimize.model.{Program, SSA}
import org.objectweb.asm.Opcodes._
import org.objectweb.asm.tree._
import scala.collection.mutable

/**
  * Converts the hybrid dataflow/controlflow graph generated by the Walker
  * back into executable bytecode, without all the unreachable, unused or
  * constant-folded instructions
  */

object CodeGen{
  def apply(program: Program,
            allVertices: Set[SSA.Node],
            nodesToBlocks: Map[SSA.Val, SSA.Block],
            cfg: Seq[(SSA.Control, SSA.Control)],
            naming: Namer.Result) = {
    val blocksToNodes = nodesToBlocks.groupBy(_._2).map{case (k, v) => (k, v.keys)}
    val sortedControls = sortControlFlowGraph(cfg)

    val blockIndices = sortedControls.zipWithIndex.toMap

    val labels = sortedControls.map(_ -> new LabelNode()).toMap
    val savedLocalNumbers = naming.savedLocals.collect{case (k: SSA.Val, v) => (k, v._1)}
    val blockCode = mutable.Buffer.empty[(Seq[AbstractInsnNode], Option[AbstractInsnNode])]
    for(control <- sortedControls){
//      pprint.log(block)
      val insns = mutable.Buffer.empty[AbstractInsnNode]
      insns.append(labels(control))
      control match{
        case _: SSA.Jump =>
          val code = generateControlBytecode(
            control,
            savedLocalNumbers,
            jumpLabel = { srcBlock =>
              labels(srcBlock.downstreamList.collect{case t: SSA.True => t}.head)
            },
            fallthroughLabel = {srcBlock =>
              val destination = srcBlock.downstreamList.collect{case t: SSA.False => t}.head
              if (blockIndices(destination) == blockIndices(control) + 1) None
              else Some(labels(destination))
            }
          )

          insns.appendAll(code)
        case block: SSA.Block =>
          val blockNodes = blocksToNodes.getOrElse(block, Nil).toSeq.sortBy(naming.finalOrderingMap)
          for(node <- blockNodes if naming.savedLocals.contains(node) && !node.isInstanceOf[SSA.Arg]){
            //        pprint.log(node)
            val nodeInsns = generateValBytecode(
              node,
              savedLocalNumbers,
              node.downstreamList.exists(blockNodes.contains)
            )
            insns.appendAll(nodeInsns)
          }
      }

      val downstreamBlocks = control.downstreamList.collect{case b: SSA.Control => b}

      val footer = downstreamBlocks.toSeq match{
        case Seq(d) if blockIndices(d) != blockIndices(control) + 1 => Some(new JumpInsnNode(GOTO, labels(d)))
        case _ => None
      }

      blockCode.append(insns -> footer)
    }

    naming.savedLocals.keysIterator.foreach{
      case phi: SSA.Phi =>
        for((k, v) <- phi.incoming){
          val (insns, footer) = blockCode(blockIndices(k))
          blockCode(blockIndices(k)) = (
            insns ++
            Seq(
              new VarInsnNode(ILOAD, savedLocalNumbers(v)),
              new VarInsnNode(ISTORE, savedLocalNumbers(phi))
            ),
            footer
          )

        }
      case _ => //do nothing
    }


    val finalInsns = new InsnList()
    for((insns, footer) <- blockCode){
      insns.foreach(finalInsns.add)
      footer.foreach(finalInsns.add)
    }

    (blockCode, finalInsns)
  }

  def sortControlFlowGraph(cfg: Seq[(SSA.Control, SSA.Control)]) = {
    val predecessor = cfg.groupBy(_._2).map { case (k, v) => (k, v.map(_._1)) }

    val startBlock = cfg
      .flatMap { case (a, b) => Seq(a, b) }
      .find(!predecessor.contains(_))
      .get

    val successor = cfg.groupBy(_._1).map { case (k, v) => (k, v.map(_._2)) }
    val sortedControls = mutable.LinkedHashSet.empty[SSA.Control]

    def sortBlocks(block: SSA.Control): Unit = if (!sortedControls(block)) {
      sortedControls.add(block)
      for (s <- successor.getOrElse(block, Nil)) sortBlocks(s)
    }

    sortBlocks(startBlock)
    sortedControls
  }


  def rec(ssa: SSA.Val, savedLocals: Map[SSA.Val, Int]): Seq[AbstractInsnNode] = {
    if (savedLocals.contains(ssa)){
      Seq(
        new VarInsnNode(
          ssa.jtype match{
            case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => ILOAD
            case JType.Prim.J => LLOAD
            case JType.Prim.F => FLOAD
            case JType.Prim.D => DLOAD
            case _ => ALOAD
          },
          savedLocals(ssa)
        )
      )
    }else generateValBytecode(ssa, savedLocals, false)
  }

  def generateControlBytecode(ssa: SSA.Control,
                              savedLocals: Map[SSA.Val, Int],
                              jumpLabel: SSA.Control => LabelNode,
                              fallthroughLabel: SSA.Control => Option[LabelNode]): Seq[AbstractInsnNode] = {
    val upstreams = ssa.upstream.collect{case n: SSA.Val => n}.flatMap(rec(_, savedLocals))
    val current: Seq[AbstractInsnNode] = ssa match{
      case r: SSA.Merge => Nil
      case n @ SSA.UnaBranch(block, a, opcode) =>
        val goto = fallthroughLabel(n).map(new JumpInsnNode(GOTO, _))
        val jump = Seq(new JumpInsnNode(opcode.i, jumpLabel(n)))
        jump ++ goto

      case n @ SSA.BinBranch(block, a, b, opcode) =>
        val goto = fallthroughLabel(n).map(new JumpInsnNode(GOTO, _))
        val jump = Seq(new JumpInsnNode(opcode.i, jumpLabel(n)))
        jump ++ goto
      case _: SSA.True => Nil
      case _: SSA.False => Nil
      case SSA.ReturnVal(block, a) =>
        Seq(new InsnNode(
          a.jtype match{
            case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => IRETURN
            case JType.Prim.J => LRETURN
            case JType.Prim.F => FRETURN
            case JType.Prim.D => DRETURN
            case _ => ARETURN
          }
        ))

      case SSA.Return(block) => Seq(new InsnNode(RETURN))
      case SSA.AThrow(_, src) => Seq(new InsnNode(ATHROW))
      case SSA.TableSwitch(_, src, min, max) => ???
      case SSA.LookupSwitch(_, src, keys) => ???
    }

    upstreams ++ current

  }

  def generateValBytecode(ssa: SSA.Val,
                          savedLocals: Map[SSA.Val, Int],
                          usedInBlock: Boolean): Seq[AbstractInsnNode] = {
    if (ssa.isInstanceOf[SSA.Phi]) Nil
    else {
      val upstreams = ssa.upstream.collect{case n: SSA.Val => n}.flatMap(rec(_, savedLocals))
      val current: Seq[AbstractInsnNode] = ssa match{

        case n: SSA.Copy => Nil

        case _: SSA.Phi => Nil
        case SSA.Arg(index, typeSize) => Nil
        case SSA.BinOp(a, b, opcode) => Seq(new InsnNode(opcode.i))
        case SSA.UnaOp(a, opcode) => Seq(new InsnNode(opcode.i))
        case SSA.CheckCast(src, desc) => ???
        case SSA.ArrayLength(src) => ???
        case SSA.InstanceOf(src, desc) => ???
        case SSA.PushI(value) => Seq(value match{
          case -1 => new InsnNode(ICONST_M1)
          case 0 => new InsnNode(ICONST_0)
          case 1 => new InsnNode(ICONST_1)
          case 2 => new InsnNode(ICONST_2)
          case 3 => new InsnNode(ICONST_3)
          case 4 => new InsnNode(ICONST_4)
          case 5 => new InsnNode(ICONST_5)
          case _ =>
            if (-128 <= value && value < 127) new IntInsnNode(BIPUSH, value)
            else if (-32768 <= value && value <= 32767) new IntInsnNode(BIPUSH, value)
            else new LdcInsnNode(value)
        })
        case SSA.PushJ(value) => Seq(value match{
          case 0 => new InsnNode(LCONST_0)
          case 1 => new InsnNode(LCONST_1)
          case _ => new LdcInsnNode(value)
        })
        case SSA.PushF(value) => Seq(value match{
          case 0 => new InsnNode(FCONST_0)
          case 1 => new InsnNode(FCONST_1)
          case 2 => new InsnNode(FCONST_2)
          case _ => new LdcInsnNode(value)
        })
        case SSA.PushD(value) => Seq(value match{
          case 0 => new InsnNode(DCONST_0)
          case 1 => new InsnNode(DCONST_1)
          case _ => new LdcInsnNode(value)
        })
        case SSA.PushS(value) => Seq(new LdcInsnNode(value))
        case SSA.PushNull() => Seq(new InsnNode(ACONST_NULL))
        case SSA.PushCls(value) =>
          Seq(new LdcInsnNode(org.objectweb.asm.Type.getType(value.name)))
        case SSA.InvokeStatic(srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
        case SSA.InvokeSpecial(srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
        case SSA.InvokeVirtual(srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
        case SSA.InvokeDynamic(name, desc, bsTag, bsOwner, bsName, bsDesc, bsArgs) => ???
        case SSA.New(cls) => ???
        case SSA.NewArray(src, typeRef) => ???
        case SSA.MultiANewArray(desc, dims) => ???
        case SSA.PutStatic(src, cls, name, desc) => ???
        case SSA.GetStatic(cls, name, desc) => ???
        case SSA.PutField(src, obj, owner, name, desc) => ???
        case SSA.GetField(obj, owner, name, desc) => ???
        case SSA.PutArray(src, indexSrc, array) => ???
        case SSA.GetArray(indexSrc, array, typeSize) => ???
        case SSA.MonitorEnter(indexSrc) => ???
        case SSA.MonitorExit(indexSrc) => ???
      }

      val save = ssa match{
        case n: SSA.Val if savedLocals.contains(n) =>
          //          val n = savedLocals(n)
          val dup = if (usedInBlock) {
            if (n.getSize == 1) Seq(new InsnNode(DUP))
            else Seq(new InsnNode(DUP2))
          } else Nil
          dup ++ Seq(
            new VarInsnNode(
              n.jtype match{
                case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => ISTORE
                case JType.Prim.J => LSTORE
                case JType.Prim.F => FSTORE
                case JType.Prim.D => DSTORE
                case _ => ASTORE
              },
              savedLocals(n)
            )
          )
        case _ => Nil
      }

      upstreams ++ current ++ save

    }
  }
}
