package joptimize.analysis

import java.util

import joptimize.model.{Program, SSA}
import org.objectweb.asm.Opcodes._
import org.objectweb.asm.tree._

import collection.JavaConverters._
import scala.collection.mutable

/**
  * Converts the hybrid dataflow/controlflow graph generated by the Walker
  * back into executable bytecode, without all the unreachable, unused or
  * constant-folded instructions
  */

object CodeGen{
  def renderGraph(edges: Seq[(fansi.Str, fansi.Str)]): fansi.Str = {
    val allStrings = edges.flatMap(x => Seq(x._1, x._2)).distinct
    val stringToIndex = allStrings.zipWithIndex.toMap
    val indexToString = stringToIndex.map(_.swap)
    val edgeGroups = edges.groupBy(_._2).map{case (k, v) => (k, v.map(_._1))}
    val sorted = Tarjans(allStrings.map(edgeGroups.getOrElse(_, Nil).map(stringToIndex))).flatten
    val out = mutable.Buffer.empty[fansi.Str]

    for(i <- sorted){
      val dest = allStrings(i)
      val srcs = edgeGroups.getOrElse(dest, Nil)
      out.append(dest, " <- ")
      out.append(srcs.flatMap(src => Seq(fansi.Str(", "), src)).drop(1):_*)
      out.append("\n")
    }
    fansi.Str.join(out:_*)
  }

  def findCtrl(ssa: SSA) = ssa match{
    case SSA.Return(ctrl) => ctrl
    case SSA.ReturnVal(ctrl, _) => ctrl
    case SSA.UnaBranch(ctrl, _, _) => ctrl
    case SSA.BinBranch(ctrl, _, _, _) => ctrl
  }

  def findControlFlowGraph(program: Program) = {
    val controlFlowEdges = mutable.Buffer.empty[(SSA.Control, SSA.Control)]
    val visited = mutable.Set.empty[SSA.Control]

    def rec(start: SSA.Control): Unit = if (!visited(start)){
      visited.add(start)

      val upstreams = start match{
        case SSA.True(x) => Seq(findCtrl(x))
        case SSA.False(x) => Seq(findCtrl(x))
        case r: SSA.Region => program.regionMerges(r)
      }

      for(control <- upstreams){
        rec(control)
        controlFlowEdges.append(control -> start)
      }
    }

    program.allTerminals.foreach(x => rec(findCtrl(x)))
    controlFlowEdges
  }
  def apply(program: Program, mapping: Map[SSA.Token, String]): InsnList = {
    val controlFlowEdges = findControlFlowGraph(program)

    println(
      renderGraph(
        controlFlowEdges.map{case (k, v) => (fansi.Color.Cyan(mapping(k)), fansi.Color.Cyan(mapping(v)))} ++
        program.allTerminals.map{t =>
          (
            fansi.Color.Cyan(mapping(findCtrl(t))),
            t match{ case _: SSA.Return | _: SSA.ReturnVal => fansi.Color.Yellow("return")}
          )
        }
      )
    )
    ???
  }
}
//object CodeGen {
//
//  def apply(allVisitedBlocks: Seq[Walker.BlockResult],
//            merges: Seq[(Frame[SSA], Frame[SSA])],
//            initialArgs: Seq[SSA.Arg],
//            inferredTypes: util.IdentityHashMap[SSA, IType]): (InsnList, Set[Int]) = {
//    val allTerminals = allVisitedBlocks.flatMap(_.terminalInsns)
//    val subCallArgLiveness = allVisitedBlocks.flatMap(_.subCallArgLiveness).toMap
//    val mergeLookup = mutable.Map.empty[SSA, mutable.Buffer[SSA]]
//
//    for((lhs, rhs) <- merges){
//      lhs.zipForeach(rhs){(l, r) =>
//        mergeLookup.getOrElseUpdate(l, mutable.Buffer()) += r
//      }
//    }
//
//    val (allVertices, roots, downstreamEdges) =
//      Util.breadthFirstAggregation[SSA](allTerminals.toSet){ ssa =>
//        ssa.upstream ++ mergeLookup.getOrElse(ssa, Nil)
//      }
//
//    val saveable = downstreamEdges
//      .groupBy(_._1)
//      .map{
//        case (k: SSA.PushI, _) => (k, false)
//        case (k: SSA.PushJ, _) => (k, false)
//        case (k: SSA.PushF, _) => (k, false)
//        case (k: SSA.PushD, _) => (k, false)
//        case (k: SSA.PushS, _) => (k, false)
//        case (k: SSA.PushNull, _) => (k, false)
//        case (k: SSA.PushCls, _) => (k, false)
//        case (k, x) =>
//          val n = x.distinct.size
//          (k, n > 1 || n == 1 && allTerminals.contains(k))
//      }
//
//    val liveArgumentIndices = for{
//      (a, i) <- initialArgs.zipWithIndex
//      if roots(a)
//    } yield i
//
//
//    val savedLocals = new util.IdentityHashMap[SSA, Int]()
//    for((a, i) <- initialArgs.zipWithIndex){
//      savedLocals.put(a, i)
//    }
//    val startLabels = allVisitedBlocks.map(_.blockInsns -> new LabelNode()).toMap
//
//    val blockInsns: Seq[Seq[AbstractInsnNode]] = for((block, blockIndex) <- allVisitedBlocks.zipWithIndex) yield {
//      def rec(ssa: SSA): Seq[AbstractInsnNode] = {
//        if (savedLocals.containsKey(ssa)){
//          Seq(
//            new VarInsnNode(
//              inferredTypes.get(ssa).widen match{
//                case JType.Prim.I => ILOAD
//                case JType.Prim.J => LLOAD
//                case JType.Prim.F => FLOAD
//                case JType.Prim.D => DLOAD
//                case _ => ALOAD
//              },
//              savedLocals.get(ssa)
//            )
//          )
//        }else{
//          val upstreams = ssa.upstream.flatMap(rec)
//          val current: Seq[AbstractInsnNode] = ssa match{
//            case SSA.Arg(index, typeSize) => ??? // shouldn't happen
//            case SSA.BinOp(a, b, opcode) => Seq(new InsnNode(opcode.i))
//            case SSA.UnaryOp(a, opcode) => Seq(new InsnNode(opcode.i))
//            case SSA.UnaryBranch(a, target, opcode) =>
//              Seq(new JumpInsnNode(opcode.i, startLabels(target)))
//            case SSA.BinBranch(a, b, target, opcode) =>
//              Seq(new JumpInsnNode(opcode.i, startLabels(target)))
//            case SSA.ReturnVal(a) =>
//              Seq(new InsnNode(
//                inferredTypes.get(a).widen match{
//                  case JType.Prim.I | JType.Prim.B | JType.Prim.S | JType.Prim.C => IRETURN
//                  case JType.Prim.J => LRETURN
//                  case JType.Prim.F => FRETURN
//                  case JType.Prim.D => DRETURN
//                  case _ => ARETURN
//                }
//              ))
//
//            case SSA.Return() => Seq(new InsnNode(RETURN))
//            case SSA.AThrow(src) => Seq(new InsnNode(ATHROW))
//            case SSA.TableSwitch(src, min, max, default, targets) => ???
//            case SSA.LookupSwitch(src, default, keys, targets) => ???
//            case SSA.Goto(target) => ???
//            case SSA.CheckCast(src, desc) => ???
//            case SSA.ArrayLength(src) => ???
//            case SSA.InstanceOf(src, desc) => ???
//            case SSA.PushI(value) => Seq(value match{
//              case -1 => new InsnNode(ICONST_M1)
//              case 0 => new InsnNode(ICONST_0)
//              case 1 => new InsnNode(ICONST_1)
//              case 2 => new InsnNode(ICONST_2)
//              case 3 => new InsnNode(ICONST_3)
//              case 4 => new InsnNode(ICONST_4)
//              case 5 => new InsnNode(ICONST_5)
//              case _ =>
//                if (-128 <= value && value < 127) new IntInsnNode(BIPUSH, value)
//                else if (-32768 <= value && value <= 32767) new IntInsnNode(BIPUSH, value)
//                else new LdcInsnNode(value)
//            })
//            case SSA.PushJ(value) => Seq(value match{
//              case 0 => new InsnNode(LCONST_0)
//              case 1 => new InsnNode(LCONST_1)
//              case _ => new LdcInsnNode(value)
//            })
//            case SSA.PushF(value) => Seq(value match{
//              case 0 => new InsnNode(FCONST_0)
//              case 1 => new InsnNode(FCONST_1)
//              case 2 => new InsnNode(FCONST_2)
//              case _ => new LdcInsnNode(value)
//            })
//            case SSA.PushD(value) => Seq(value match{
//              case 0 => new InsnNode(DCONST_0)
//              case 1 => new InsnNode(DCONST_1)
//              case _ => new LdcInsnNode(value)
//            })
//            case SSA.PushS(value) => Seq(new LdcInsnNode(value))
//            case SSA.PushNull() => Seq(new InsnNode(ACONST_NULL))
//            case SSA.PushCls(value) =>
//              Seq(new LdcInsnNode(org.objectweb.asm.Type.getType(value.name)))
//            case SSA.InvokeStatic(state, srcs, cls, name, desc) =>
//              srcs.flatMap(rec) ++
//              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
//            case SSA.InvokeSpecial(state, srcs, cls, name, desc) =>
//              srcs.flatMap(rec) ++
//              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
//            case SSA.InvokeVirtual(state, srcs, cls, name, desc) =>
//              srcs.flatMap(rec) ++
//              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
//            case SSA.InvokeDynamic(name, desc, bsTag, bsOwner, bsName, bsDesc, bsArgs) => ???
//            case SSA.New(cls) => ???
//            case SSA.NewArray(src, typeRef) => ???
//            case SSA.MultiANewArray(desc, dims) => ???
//            case SSA.PutStatic(state, src, cls, name, desc) => ???
//            case SSA.GetStatic(state, cls, name, desc) => ???
//            case SSA.PutField(state, src, obj, owner, name, desc) => ???
//            case SSA.GetField(state, obj, owner, name, desc) => ???
//            case SSA.PutArray(state, src, indexSrc, array) => ???
//            case SSA.GetArray(state, indexSrc, array, typeSize) => ???
//            case SSA.MonitorEnter(indexSrc) => ???
//            case SSA.MonitorExit(indexSrc) => ???
//          }
//          val save =
//            if (!saveable.getOrElse(ssa, false)) Nil
//            else {
//              val n = savedLocals.size()
//              val res = Seq(
//                new InsnNode(DUP),
//                new VarInsnNode(
//                  inferredTypes.get(ssa).widen match{
//                    case JType.Prim.I => ISTORE
//                    case JType.Prim.J => LSTORE
//                    case JType.Prim.F => FSTORE
//                    case JType.Prim.D => DSTORE
//                    case _ => ASTORE
//                  },
//                  n
//                )
//              )
//              savedLocals.put(ssa, n)
//              res
//            }
//
//          upstreams ++ current ++ save
//        }
//      }
//
//      val renderRoots = block.blockInsns.value.filter(i => block.terminalInsns.contains(i) || saveable.getOrElse(i, false))
//      Seq(startLabels(block.blockInsns)) ++ renderRoots.flatMap(rec)
//    }
//    val outputInsns = new InsnList()
//    blockInsns.flatten.foreach(outputInsns.add)
//
//    (outputInsns, liveArgumentIndices.toSet)
//  }
//}
//
//
