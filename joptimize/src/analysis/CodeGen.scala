package joptimize.analysis

import java.util

import joptimize.model.{Program, SSA}
import org.objectweb.asm.Opcodes._
import org.objectweb.asm.tree._

import collection.JavaConverters._
import scala.collection.mutable

/**
  * Converts the hybrid dataflow/controlflow graph generated by the Walker
  * back into executable bytecode, without all the unreachable, unused or
  * constant-folded instructions
  */

object CodeGen{
  def renderGraph(edges: Seq[(fansi.Str, fansi.Str)]): fansi.Str = {
    val allStrings = edges.flatMap(x => Seq(x._1, x._2)).distinct
    val stringToIndex = allStrings.zipWithIndex.toMap
    val indexToString = stringToIndex.map(_.swap)
    val edgeGroups = edges.groupBy(_._2).map{case (k, v) => (k, v.map(_._1))}
    val sorted = Tarjans(allStrings.map(edgeGroups.getOrElse(_, Nil).map(stringToIndex))).flatten
    val out = mutable.Buffer.empty[fansi.Str]

    for(i <- sorted){
      val dest = allStrings(i)
      val srcs = edgeGroups.getOrElse(dest, Nil)
      out.append(dest, " <- ")
      out.append(srcs.flatMap(src => Seq(fansi.Str(", "), src)).drop(1):_*)
      out.append("\n")
    }
    fansi.Str.join(out:_*)
  }

  def findCtrl(ssa: SSA) = ssa match{
    case SSA.Return(ctrl) => ctrl
    case SSA.ReturnVal(ctrl, _) => ctrl
    case SSA.UnaBranch(ctrl, _, _) => ctrl
    case SSA.BinBranch(ctrl, _, _, _) => ctrl
  }

  def findControlFlowGraph(program: Program) = {
    val controlFlowEdges = mutable.Buffer.empty[(SSA.Control, SSA.Control)]
    val visited = mutable.Set.empty[SSA.Control]

    def rec(start: SSA.Control): Unit = if (!visited(start)){
      visited.add(start)

      val upstreams = start match{
        case SSA.True(x) => Seq(findCtrl(x))
        case SSA.False(x) => Seq(findCtrl(x))
        case r: SSA.Region => program.regionMerges(r)
      }

      for(control <- upstreams){
        rec(control)
        controlFlowEdges.append(control -> start)
      }
    }

    program.allTerminals.foreach(x => rec(findCtrl(x)))
    controlFlowEdges
  }

  def analyzeLoops(controlFlowGraph: Seq[(SSA.Token, SSA.Token)],
                   start: SSA.Control,
                   mapping: Map[SSA.Token, String]) = {
    val (numbers, last) = numberVertices(controlFlowGraph, start)

    val nodes = numbers.map(_.swap)
    def isAncestor(w: Int, v: Int) = w <= v && v <= last(nodes(w))
    val upstreamEdges = controlFlowGraph.groupBy(x => numbers(x._2)).map{case (k, vs) => (k, vs.map(x => numbers(x._1)))}

    val nonBackPreds = new Array[Set[Int]](numbers.size)
    val backPreds = new Array[Set[Int]](numbers.size)
    val header = new Array[Option[Int]](numbers.size)
    val tpe = new Array[String](numbers.size)
    for(w <- Range(0, numbers.size)){
      nonBackPreds(w) = Set()
      backPreds(w) = Set()
      header(w) = Some(0)
      tpe(w) = "nonheader"

      for(v <- upstreamEdges.getOrElse(w, Set.empty)){
        if (isAncestor(w, v)) backPreds(w) += v
        else nonBackPreds(w) += v
      }
    }

    header(0) = None

    val disjointSet = DisjointSet.empty[Int]
    numbers.values.foreach(disjointSet +=)

    for(w <- Range.inclusive(numbers.size - 1, 0, -1)){
      var p = Set.empty[Int]
      for(v <- backPreds(w)){
        if (v != w) p += disjointSet(v)
        else tpe(w) = "self"
      }
      var worklist = p
      if (p.nonEmpty) tpe(w) = "reducible"
      while(worklist.nonEmpty){
        val x = worklist.head
        worklist = worklist.tail

        for(y <- nonBackPreds(x)){
          val yPrime = disjointSet(y)
          if (!isAncestor(w, yPrime)) {
            tpe(w) = "irreducible"
            nonBackPreds(w) += yPrime
          } else if (!p.contains(yPrime) && yPrime != w){
            p += yPrime
            worklist += yPrime
          }
        }
      }


      for(x <- p){
        header(x) = Some(w)
        disjointSet.union(x, w)
      }
    }

    (disjointSet.sets, tpe, nodes, header)
  }

  def numberVertices(controlFlowGraph: Seq[(SSA.Token, SSA.Token)], start: SSA.Control) = {
    val downstreamEdges = controlFlowGraph.groupBy(_._1).map { case (k, vs) => (k, vs.map(_._2)) }
    val numbers = mutable.Map.empty[SSA.Token, Int]


    var current = 0
    val last = mutable.Map.empty[SSA.Token, Int]

    def dfs(a: SSA.Token): Unit = {
      numbers(a) = current
      current += 1
      for (b <- downstreamEdges.getOrElse(a, Nil)) {
        if (!numbers.contains(b)) dfs(b)
      }
      last(a) = current - 1

    }

    dfs(start)
    (numbers, last)
  }

  def apply(program: Program, mapping: Map[SSA.Token, String]): InsnList = {
    val controlFlowEdges = findControlFlowGraph(program)
    val graph = controlFlowEdges ++ program.allTerminals.map{ case r: SSA.Controlled => (r.control, r)}
    println(
      renderGraph(
        graph.map{
          case (l: SSA.Control, r: SSA.Controlled) => (fansi.Color.Cyan(mapping(l)), fansi.Color.Yellow("return"))
          case (l: SSA.Control, r: SSA.Control) => (fansi.Color.Cyan(mapping(l)), fansi.Color.Cyan(mapping(r)))
        }
      )
    )

    val (loopSets, tpe, nodes, header) = analyzeLoops(
      graph,
      program.regionMerges.find(_._2.isEmpty).get._1,
      mapping)

    val prettyLoops = loopSets.map(_.map(x =>
      (mapping(nodes(x)), tpe(x), header(x).map(nodes).map(mapping))
    ))
    pprint.log(prettyLoops)

    ???
  }
}
//object CodeGen {
//
//  def apply(allVisitedBlocks: Seq[Walker.BlockResult],
//            merges: Seq[(Frame[SSA], Frame[SSA])],
//            initialArgs: Seq[SSA.Arg],
//            inferredTypes: util.IdentityHashMap[SSA, IType]): (InsnList, Set[Int]) = {
//    val allTerminals = allVisitedBlocks.flatMap(_.terminalInsns)
//    val subCallArgLiveness = allVisitedBlocks.flatMap(_.subCallArgLiveness).toMap
//    val mergeLookup = mutable.Map.empty[SSA, mutable.Buffer[SSA]]
//
//    for((lhs, rhs) <- merges){
//      lhs.zipForeach(rhs){(l, r) =>
//        mergeLookup.getOrElseUpdate(l, mutable.Buffer()) += r
//      }
//    }
//
//    val (allVertices, roots, downstreamEdges) =
//      Util.breadthFirstAggregation[SSA](allTerminals.toSet){ ssa =>
//        ssa.upstream ++ mergeLookup.getOrElse(ssa, Nil)
//      }
//
//    val saveable = downstreamEdges
//      .groupBy(_._1)
//      .map{
//        case (k: SSA.PushI, _) => (k, false)
//        case (k: SSA.PushJ, _) => (k, false)
//        case (k: SSA.PushF, _) => (k, false)
//        case (k: SSA.PushD, _) => (k, false)
//        case (k: SSA.PushS, _) => (k, false)
//        case (k: SSA.PushNull, _) => (k, false)
//        case (k: SSA.PushCls, _) => (k, false)
//        case (k, x) =>
//          val n = x.distinct.size
//          (k, n > 1 || n == 1 && allTerminals.contains(k))
//      }
//
//    val liveArgumentIndices = for{
//      (a, i) <- initialArgs.zipWithIndex
//      if roots(a)
//    } yield i
//
//
//    val savedLocals = new util.IdentityHashMap[SSA, Int]()
//    for((a, i) <- initialArgs.zipWithIndex){
//      savedLocals.put(a, i)
//    }
//    val startLabels = allVisitedBlocks.map(_.blockInsns -> new LabelNode()).toMap
//
//    val blockInsns: Seq[Seq[AbstractInsnNode]] = for((block, blockIndex) <- allVisitedBlocks.zipWithIndex) yield {
//      def rec(ssa: SSA): Seq[AbstractInsnNode] = {
//        if (savedLocals.containsKey(ssa)){
//          Seq(
//            new VarInsnNode(
//              inferredTypes.get(ssa).widen match{
//                case JType.Prim.I => ILOAD
//                case JType.Prim.J => LLOAD
//                case JType.Prim.F => FLOAD
//                case JType.Prim.D => DLOAD
//                case _ => ALOAD
//              },
//              savedLocals.get(ssa)
//            )
//          )
//        }else{
//          val upstreams = ssa.upstream.flatMap(rec)
//          val current: Seq[AbstractInsnNode] = ssa match{
//            case SSA.Arg(index, typeSize) => ??? // shouldn't happen
//            case SSA.BinOp(a, b, opcode) => Seq(new InsnNode(opcode.i))
//            case SSA.UnaryOp(a, opcode) => Seq(new InsnNode(opcode.i))
//            case SSA.UnaryBranch(a, target, opcode) =>
//              Seq(new JumpInsnNode(opcode.i, startLabels(target)))
//            case SSA.BinBranch(a, b, target, opcode) =>
//              Seq(new JumpInsnNode(opcode.i, startLabels(target)))
//            case SSA.ReturnVal(a) =>
//              Seq(new InsnNode(
//                inferredTypes.get(a).widen match{
//                  case JType.Prim.I | JType.Prim.B | JType.Prim.S | JType.Prim.C => IRETURN
//                  case JType.Prim.J => LRETURN
//                  case JType.Prim.F => FRETURN
//                  case JType.Prim.D => DRETURN
//                  case _ => ARETURN
//                }
//              ))
//
//            case SSA.Return() => Seq(new InsnNode(RETURN))
//            case SSA.AThrow(src) => Seq(new InsnNode(ATHROW))
//            case SSA.TableSwitch(src, min, max, default, targets) => ???
//            case SSA.LookupSwitch(src, default, keys, targets) => ???
//            case SSA.Goto(target) => ???
//            case SSA.CheckCast(src, desc) => ???
//            case SSA.ArrayLength(src) => ???
//            case SSA.InstanceOf(src, desc) => ???
//            case SSA.PushI(value) => Seq(value match{
//              case -1 => new InsnNode(ICONST_M1)
//              case 0 => new InsnNode(ICONST_0)
//              case 1 => new InsnNode(ICONST_1)
//              case 2 => new InsnNode(ICONST_2)
//              case 3 => new InsnNode(ICONST_3)
//              case 4 => new InsnNode(ICONST_4)
//              case 5 => new InsnNode(ICONST_5)
//              case _ =>
//                if (-128 <= value && value < 127) new IntInsnNode(BIPUSH, value)
//                else if (-32768 <= value && value <= 32767) new IntInsnNode(BIPUSH, value)
//                else new LdcInsnNode(value)
//            })
//            case SSA.PushJ(value) => Seq(value match{
//              case 0 => new InsnNode(LCONST_0)
//              case 1 => new InsnNode(LCONST_1)
//              case _ => new LdcInsnNode(value)
//            })
//            case SSA.PushF(value) => Seq(value match{
//              case 0 => new InsnNode(FCONST_0)
//              case 1 => new InsnNode(FCONST_1)
//              case 2 => new InsnNode(FCONST_2)
//              case _ => new LdcInsnNode(value)
//            })
//            case SSA.PushD(value) => Seq(value match{
//              case 0 => new InsnNode(DCONST_0)
//              case 1 => new InsnNode(DCONST_1)
//              case _ => new LdcInsnNode(value)
//            })
//            case SSA.PushS(value) => Seq(new LdcInsnNode(value))
//            case SSA.PushNull() => Seq(new InsnNode(ACONST_NULL))
//            case SSA.PushCls(value) =>
//              Seq(new LdcInsnNode(org.objectweb.asm.Type.getType(value.name)))
//            case SSA.InvokeStatic(state, srcs, cls, name, desc) =>
//              srcs.flatMap(rec) ++
//              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
//            case SSA.InvokeSpecial(state, srcs, cls, name, desc) =>
//              srcs.flatMap(rec) ++
//              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
//            case SSA.InvokeVirtual(state, srcs, cls, name, desc) =>
//              srcs.flatMap(rec) ++
//              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
//            case SSA.InvokeDynamic(name, desc, bsTag, bsOwner, bsName, bsDesc, bsArgs) => ???
//            case SSA.New(cls) => ???
//            case SSA.NewArray(src, typeRef) => ???
//            case SSA.MultiANewArray(desc, dims) => ???
//            case SSA.PutStatic(state, src, cls, name, desc) => ???
//            case SSA.GetStatic(state, cls, name, desc) => ???
//            case SSA.PutField(state, src, obj, owner, name, desc) => ???
//            case SSA.GetField(state, obj, owner, name, desc) => ???
//            case SSA.PutArray(state, src, indexSrc, array) => ???
//            case SSA.GetArray(state, indexSrc, array, typeSize) => ???
//            case SSA.MonitorEnter(indexSrc) => ???
//            case SSA.MonitorExit(indexSrc) => ???
//          }
//          val save =
//            if (!saveable.getOrElse(ssa, false)) Nil
//            else {
//              val n = savedLocals.size()
//              val res = Seq(
//                new InsnNode(DUP),
//                new VarInsnNode(
//                  inferredTypes.get(ssa).widen match{
//                    case JType.Prim.I => ISTORE
//                    case JType.Prim.J => LSTORE
//                    case JType.Prim.F => FSTORE
//                    case JType.Prim.D => DSTORE
//                    case _ => ASTORE
//                  },
//                  n
//                )
//              )
//              savedLocals.put(ssa, n)
//              res
//            }
//
//          upstreams ++ current ++ save
//        }
//      }
//
//      val renderRoots = block.blockInsns.value.filter(i => block.terminalInsns.contains(i) || saveable.getOrElse(i, false))
//      Seq(startLabels(block.blockInsns)) ++ renderRoots.flatMap(rec)
//    }
//    val outputInsns = new InsnList()
//    blockInsns.flatten.foreach(outputInsns.add)
//
//    (outputInsns, liveArgumentIndices.toSet)
//  }
//}
//
//
