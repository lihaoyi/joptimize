package joptimize.analysis

import java.util

import joptimize.Util
import joptimize.model.JType
//import joptimize.analysis.Renderer.sortVerticesForPrinting
import joptimize.graph.{HavlakLoopTree, LengauerTarjanDominatorTree, TarjansStronglyConnectedComponents}
import joptimize.model.{Program, SSA}
import org.objectweb.asm.Opcodes._
import org.objectweb.asm.tree._

import collection.JavaConverters._
import scala.collection.mutable

/**
  * Converts the hybrid dataflow/controlflow graph generated by the Walker
  * back into executable bytecode, without all the unreachable, unused or
  * constant-folded instructions
  */

object CodeGen{
  def apply(program: Program, mapping: Map[SSA.Node, String]): InsnList = {
    val controlFlowEdges = Util.findControlFlowGraph(program)


    println(
      Renderer.renderGraph(
        controlFlowEdges,
        (lhs, rhs, indent) =>
          fansi.Color.Magenta(mapping(lhs)) ++
          " <- " ++
          fansi.Str.join(rhs.flatMap(r => Seq[fansi.Str](", ", fansi.Color.Magenta(mapping(r)))).drop(1):_*)
      )
    )

    val loopTree = HavlakLoopTree.analyzeLoops(controlFlowEdges)

    def rec(l: HavlakLoopTree.Loop[SSA.Block], depth: Int, label0: List[Int]): Unit = {
      val indent = "    " * depth
      val id = label0.reverseIterator.map("-" + _).mkString
      val reducible = if (l.isReducible) "" else " (Irreducible)"
      val header = mapping(l.primaryHeader)
      val blockStr = l.basicBlocks.filter(_ != l.primaryHeader).map(x => mapping(x)).mkString("[", ", ", "]")
      println(s"${indent}loop$id$reducible, header: $header, blocks: $blockStr")

      for((c, i) <- l.children.zipWithIndex)rec(c, depth + 1, i :: label0)
    }

    rec(loopTree, 0, Nil)

    val (immediateDominators, dominatorDepth) = findDominators(controlFlowEdges)

    RegisterAllocator.apply(program, immediateDominators)

    val nodesToBlocks = schedule(
      program, loopTree,
      dominatorDepth, immediateDominators,
      controlFlowEdges, mapping
    )

    val (finalOrderingMap, saveable, savedLocals) = Util.findSaveable(program, nodesToBlocks)
    val blocksToNodes = nodesToBlocks.groupBy(_._2).map{case (k, v) => (k, v.keys)}
    val (stringified, mapping2) = Renderer.renderSSA(program, nodesToBlocks)
    pprint.log(nodesToBlocks.mapValues(mapping2))

    println()
    println(stringified)
    println()

    val cfg = Util.findControlFlowGraph(program)
    val allVertices = cfg.flatMap{case (a, b) => Seq(a, b)}
    val predecessor = cfg.groupBy(_._2).map{case (k, v) => (k, v.map(_._1))}
    val startNode = allVertices.find(!predecessor.contains(_)).get
    val successor = cfg.groupBy(_._1).map{case (k, v) => (k, v.map(_._2))}
    val sortedBlocks = mutable.LinkedHashSet.empty[SSA.Block]
    def sortBlocks(block: SSA.Block): Unit = if (!sortedBlocks(block)){
      sortedBlocks.add(block)
      for(s <- successor.getOrElse(block, Nil)) sortBlocks(s)
    }

    sortBlocks(startNode)

    val blockIndices = sortedBlocks.zipWithIndex.toMap

    pprint.log(sortedBlocks.map(mapping2))
    val output = new InsnList()
    val labels = sortedBlocks.map(_ -> new LabelNode()).toMap
    val savedLocalNumbers = savedLocals.map{case (k, v) => (k, (v._2.startsWith("local"), v._1))}.toMap
    pprint.log(savedLocalNumbers)
    val blockCode = mutable.Buffer.empty[(Seq[AbstractInsnNode], Option[AbstractInsnNode])]
    for(block <- sortedBlocks){

      val insns = mutable.Buffer.empty[AbstractInsnNode]
      insns.append(labels(block))

      if (block.isInstanceOf[SSA.BinBranch] || block.isInstanceOf[SSA.UnaBranch]){
        val code = generateBytecode(
          block,
          savedLocalNumbers,
          jumpLabel = { srcBlock =>
            labels(
              srcBlock.downstream.collect{case t: SSA.True => t}.head
            )
          },
          fallthroughLabel = {srcBlock =>
            val destination = srcBlock.downstream.collect{case t: SSA.False => t}.head
            if (blockIndices(destination) == blockIndices(block) + 1) None
            else Some(labels(destination))
          }
        )

        insns.appendAll(code)
      }

      val blockNodes = blocksToNodes.getOrElse(block, Nil)
      for(node <- blockNodes if savedLocals.contains(node) && !node.isInstanceOf[SSA.Arg]){
        val nodeInsns = generateBytecode(node, savedLocalNumbers, _ => ???, _ => ???)
        insns.appendAll(nodeInsns)
      }

      val downstreamBlocks = block.downstream.collect{case b: SSA.Block => b}

      val footer = downstreamBlocks.toSeq match{
        case Seq(d) if blockIndices(d) != blockIndices(block) + 1 => Some(new JumpInsnNode(GOTO, labels(d)))
        case _ => None
      }

      blockCode.append(insns -> footer)
    }

    savedLocals.keysIterator.foreach{
      case phi: SSA.Phi =>
        pprint.log(phi)
        for((k, v) <- phi.incoming){
          pprint.log(k -> v)
          val (insns, footer) = blockCode(blockIndices(k))
          blockCode(blockIndices(k)) = (
            insns ++
            Seq(
              new VarInsnNode(ILOAD, savedLocalNumbers(v)._2),
              new VarInsnNode(ISTORE, savedLocalNumbers(phi)._2)
            ),
            footer
          )

        }
      case _ => //do nothing
    }


    for((insns, footer) <- blockCode){
      insns.foreach(output.add)
      footer.foreach(output.add)
    }

    println()
    for((insns, footer) <- blockCode){
      for(insn <- insns ++ footer) println(Renderer.renderInsns(output, insn))
      println()
    }

    ???
  }

  def schedule(program: Program,
               loopTree: HavlakLoopTree.Loop[SSA.Block],
               dominatorDepth: Map[SSA.Block, Int],
               immediateDominator: Map[SSA.Block, SSA.Block],
               graph: Seq[(SSA.Block, SSA.Block)],
               mapping: Map[SSA.Node, String]): Map[SSA.Val, SSA.Block] = {
    val (allVertices, roots, downstreamEdges) =
      Util.breadthFirstAggregation[SSA.Node](program.allTerminals.toSet)(_.upstream)
    val loopNestMap = mutable.LinkedHashMap.empty[SSA.Node, Int]
    def recLoop(loop: HavlakLoopTree.Loop[SSA.Block], depth: Int): Unit = {
      loop.basicBlocks.foreach(loopNestMap(_) = depth)
      loop.children.foreach(recLoop(_, depth + 1))
    }

    recLoop(loopTree, 0)

    val downstreamMap = downstreamEdges.groupBy(_._1).map{case (k, vs) => (k, vs.map(_._2))}
    val upstreamMap = downstreamEdges.groupBy(_._2).map{case (k, vs) => (k, vs.map(_._1))}
    val scheduler = new ClickScheduler(dominatorDepth, immediateDominator, mapping) {
      override def downstream(ssa: SSA.Node) = downstreamMap.getOrElse(ssa, Nil)

      override def upstream(ssa: SSA.Node) = upstreamMap.getOrElse(ssa, Nil).collect{case ssa: SSA.Val => ssa}

      override def isPinned(ssa: SSA.Node) = ssa.isInstanceOf[SSA.Block]

      override def loopNest(block: SSA.Node) = {
        assert(block != null)
        loopNestMap(block)
      }
    }

    val startBlock = (graph.map(_._1).toSet -- graph.map(_._2)).head
    allVertices.collect{
      case c: SSA.Phi => scheduler.block(c) = c.block
      case c: SSA.Val if c.upstream.isEmpty => scheduler.block(c) = startBlock
    }

    allVertices.collect{
      case scheduleRoot: SSA.Phi => scheduler.scheduleEarlyRoot(scheduleRoot)
      case scheduleRoot: SSA.Block => scheduler.scheduleEarlyRoot(scheduleRoot)
    }

    pprint.log(scheduler.block.map{case (k, v) => (k, mapping(v))}, height=9999)

    allVertices.collect{
      case scheduleRoot: SSA.Phi => scheduler.scheduleLateRoot(scheduleRoot)
      case scheduleRoot: SSA.Block => scheduler.scheduleLateRoot(scheduleRoot)
      case scheduleRoot: SSA.Val if scheduleRoot.upstream.isEmpty =>
        scheduler.scheduleLateRoot(scheduleRoot)
    }

    pprint.log(scheduler.block.map{case (k, v) => (k, mapping(v))}, height=9999)

//    ???
    scheduler.block.filter{case (k, v) => v != null}.toMap
  }

  def findDominators[T](edges: Seq[(T, T)]): (Map[T, T], Map[T, Int]) = {
    val indices = edges.flatMap{case (x, y) => Seq(x, y)}.distinct.zipWithIndex.toMap
    val nodes = indices.map(_.swap)

    val successorMap = edges.groupBy(_._1).map{case (k, v) => (indices(k), v.map(_._2).map(indices))}
    val predecessorMap = edges.groupBy(_._2).map{case (k, v) => (indices(k), v.map(_._1).map(indices))}

    val immediateDominators = new LengauerTarjanDominatorTree {
      def successors(v: Int) = successorMap.getOrElse(v, Nil)
      def predecessors(v: Int) = predecessorMap.getOrElse(v, Nil)
      def numNodes = indices.size
    }.computeDominatorTree()

    val dominatorDepth = {
      Array.tabulate(immediateDominators.length) { i =>
        var current = i
        var n = 0
        while (immediateDominators(current) != -1){
          current = immediateDominators(current)
          n += 1
        }
        n
      }
    }

    (
      immediateDominators.zipWithIndex.collect{case (v, i) if v != -1 => (nodes(i), nodes(v))}.toMap,
      dominatorDepth.zipWithIndex.map{case (v, i) => (nodes(i), v)}.toMap
    )
  }
  def generateBytecode(ssa: SSA.Node,
                       savedLocals: Map[SSA.Val, (Boolean, Int)],
                       jumpLabel: SSA.Block => LabelNode,
                       fallthroughLabel: SSA.Block => Option[LabelNode]) = {
    def rec(ssa: SSA.Val): Seq[AbstractInsnNode] = {
      if (savedLocals.contains(ssa)){
        Seq(
          new VarInsnNode(
            ILOAD,
//            inferredTypes.get(ssa).widen match{
//              case JType.Prim.I => ILOAD
//              case JType.Prim.J => LLOAD
//              case JType.Prim.F => FLOAD
//              case JType.Prim.D => DLOAD
//              case _ => ALOAD
//            },
            savedLocals(ssa)._2
          )
        )
      }else compute(ssa)
    }

    def compute(ssa: SSA.Node): Seq[AbstractInsnNode] =
      if (ssa.isInstanceOf[SSA.Phi]) Nil
      else {
        val upstreams = ssa.upstream.collect{case n: SSA.Val => n}.flatMap(rec)
        val current: Seq[AbstractInsnNode] = ssa match{
          case r: SSA.Merge => Nil
          case n: SSA.Copy => Nil
          case n @ SSA.UnaBranch(block, a, opcode) =>
            val goto = fallthroughLabel(n).map(new JumpInsnNode(GOTO, _))
            val jump = Seq(new JumpInsnNode(opcode.i, jumpLabel(n)))
            jump ++ goto

          case n @ SSA.BinBranch(block, a, b, opcode) =>
            val goto = fallthroughLabel(n).map(new JumpInsnNode(GOTO, _))
            val jump = Seq(new JumpInsnNode(opcode.i, jumpLabel(n)))
            jump ++ goto
          case _: SSA.True => Nil
          case _: SSA.False => Nil
          case SSA.ReturnVal(block, a) =>
            Seq(new InsnNode(
              IRETURN
  //            inferredTypes.get(a).widen match{
  //              case JType.Prim.I | JType.Prim.B | JType.Prim.S | JType.Prim.C => IRETURN
  //              case JType.Prim.J => LRETURN
  //              case JType.Prim.F => FRETURN
  //              case JType.Prim.D => DRETURN
  //              case _ => ARETURN
  //            }
            ))

          case SSA.Return(block) => Seq(new InsnNode(RETURN))
          case SSA.AThrow(src) => Seq(new InsnNode(ATHROW))
          case SSA.TableSwitch(src, min, max) => ???
          case SSA.LookupSwitch(src, keys) => ???

          case _: SSA.Phi => Nil
          case SSA.Arg(index, typeSize) => Nil
          case SSA.BinOp(a, b, opcode) => Seq(new InsnNode(opcode.i))
          case SSA.UnaOp(a, opcode) => Seq(new InsnNode(opcode.i))
          case SSA.CheckCast(src, desc) => ???
          case SSA.ArrayLength(src) => ???
          case SSA.InstanceOf(src, desc) => ???
          case SSA.PushI(value) => Seq(value match{
            case -1 => new InsnNode(ICONST_M1)
            case 0 => new InsnNode(ICONST_0)
            case 1 => new InsnNode(ICONST_1)
            case 2 => new InsnNode(ICONST_2)
            case 3 => new InsnNode(ICONST_3)
            case 4 => new InsnNode(ICONST_4)
            case 5 => new InsnNode(ICONST_5)
            case _ =>
              if (-128 <= value && value < 127) new IntInsnNode(BIPUSH, value)
              else if (-32768 <= value && value <= 32767) new IntInsnNode(BIPUSH, value)
              else new LdcInsnNode(value)
          })
          case SSA.PushJ(value) => Seq(value match{
            case 0 => new InsnNode(LCONST_0)
            case 1 => new InsnNode(LCONST_1)
            case _ => new LdcInsnNode(value)
          })
          case SSA.PushF(value) => Seq(value match{
            case 0 => new InsnNode(FCONST_0)
            case 1 => new InsnNode(FCONST_1)
            case 2 => new InsnNode(FCONST_2)
            case _ => new LdcInsnNode(value)
          })
          case SSA.PushD(value) => Seq(value match{
            case 0 => new InsnNode(DCONST_0)
            case 1 => new InsnNode(DCONST_1)
            case _ => new LdcInsnNode(value)
          })
          case SSA.PushS(value) => Seq(new LdcInsnNode(value))
          case SSA.PushNull() => Seq(new InsnNode(ACONST_NULL))
          case SSA.PushCls(value) =>
            Seq(new LdcInsnNode(org.objectweb.asm.Type.getType(value.name)))
          case SSA.InvokeStatic(srcs, cls, name, desc) =>
            srcs.flatMap(rec) ++
              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
          case SSA.InvokeSpecial(srcs, cls, name, desc) =>
            srcs.flatMap(rec) ++
              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
          case SSA.InvokeVirtual(srcs, cls, name, desc) =>
            srcs.flatMap(rec) ++
              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
          case SSA.InvokeDynamic(name, desc, bsTag, bsOwner, bsName, bsDesc, bsArgs) => ???
          case SSA.New(cls) => ???
          case SSA.NewArray(src, typeRef) => ???
          case SSA.MultiANewArray(desc, dims) => ???
          case SSA.PutStatic(src, cls, name, desc) => ???
          case SSA.GetStatic(cls, name, desc) => ???
          case SSA.PutField(src, obj, owner, name, desc) => ???
          case SSA.GetField(obj, owner, name, desc) => ???
          case SSA.PutArray(src, indexSrc, array) => ???
          case SSA.GetArray(indexSrc, array, typeSize) => ???
          case SSA.MonitorEnter(indexSrc) => ???
          case SSA.MonitorExit(indexSrc) => ???
        }

        val save = ssa match{
          case n: SSA.Val if savedLocals.contains(n) =>
  //          val n = savedLocals(n)
            val dup = if (savedLocals(n)._1) Seq(new InsnNode(DUP)) else Nil
            dup ++ Seq(
              new VarInsnNode(
                ISTORE,
                //                inferredTypes.get(ssa).widen match{
                //                  case JType.Prim.I => ISTORE
                //                  case JType.Prim.J => LSTORE
                //                  case JType.Prim.F => FSTORE
                //                  case JType.Prim.D => DSTORE
                //                  case _ => ASTORE
                //                },
                savedLocals(n)._2
              )
            )
          case _ => Nil
        }

        upstreams ++ current ++ save

      }

    compute(ssa)
  }
}
