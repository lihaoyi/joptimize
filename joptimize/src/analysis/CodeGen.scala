package joptimize.analysis


import joptimize.model.JType

import joptimize.model.{Program, SSA}
import org.objectweb.asm.Opcodes._
import org.objectweb.asm.tree._
import scala.collection.mutable

/**
  * Converts the hybrid dataflow/controlflow graph generated by the Walker
  * back into executable bytecode, without all the unreachable, unused or
  * constant-folded instructions
  */

object CodeGen{
  def apply(program: Program,
            allVertices: Set[SSA.Node],
            nodesToBlocks: Map[SSA.Val, SSA.Block],
            cfg: Seq[(SSA.Control, SSA.Control)],
            naming: Namer.Result) = {
    val blocksToNodes = nodesToBlocks.groupBy(_._2).map{case (k, v) => (k, v.keys)}
    val sortedControls = sortControlFlowGraph(cfg)

    val blockIndices = sortedControls.zipWithIndex.toMap

    val labels = sortedControls.map(_ -> new LabelNode()).toMap
    val savedLocalNumbers = naming.savedLocals.collect{case (k: SSA.Val, v) => (k, v._1)}
    val blockCode = mutable.Buffer.empty[(Seq[AbstractInsnNode], Option[AbstractInsnNode])]
    for(control <- sortedControls){
//      pprint.log(block)
      val insns = mutable.Buffer.empty[AbstractInsnNode]
      insns.append(labels(control))
      control match{
        case jump: SSA.Jump =>
          val code = generateJumpBytecode(
            jump,
            savedLocalNumbers,
            jumpLabel = { srcBlock =>
              labels(srcBlock.downstreamList.collect{case t: SSA.True => t}.head)
            },
            fallthroughLabel = {srcBlock =>
              val destination = srcBlock.downstreamList.collect{case t: SSA.False => t}.head
              if (blockIndices(destination) == blockIndices(control) + 1) None
              else Some(labels(destination))
            }
          )

          insns.appendAll(code)
        case block: SSA.Block =>
          val blockNodes = blocksToNodes.getOrElse(block, Nil).toSeq.sortBy(naming.finalOrderingMap)
          for(node <- blockNodes if naming.savedLocals.contains(node) && !node.isInstanceOf[SSA.Arg]){
            val nodeInsns = generateValBytecode(node, savedLocalNumbers)
            insns.appendAll(nodeInsns)
          }
      }

      val downstreamBlocks = control.downstreamList.collect{case b: SSA.Control => b}

      val footer = downstreamBlocks.toSeq match{
        case Seq(d) if blockIndices(d) != blockIndices(control) + 1 => Some(new JumpInsnNode(GOTO, labels(d)))
        case _ => None
      }

      blockCode.append(insns -> footer)
    }

    naming.savedLocals.keysIterator.foreach{
      case phi: SSA.Phi if phi.getSize != 0 =>
        for((k, v) <- phi.incoming){
          val (insns, footer) = blockCode(blockIndices(k))

          blockCode(blockIndices(k)) = (
            insns ++
            Seq(
              new VarInsnNode(loadOp(phi), savedLocalNumbers(v)),
              new VarInsnNode(saveOp(phi), savedLocalNumbers(phi))
            ),
            footer
          )

        }
      case _ => //do nothing
    }


    val finalInsns = new InsnList()
    for((insns, footer) <- blockCode){
      insns.foreach(finalInsns.add)
      footer.foreach(finalInsns.add)
    }

    (blockCode, finalInsns)
  }

  def sortControlFlowGraph(cfg: Seq[(SSA.Control, SSA.Control)]) = {
    val predecessor = cfg.groupBy(_._2).map { case (k, v) => (k, v.map(_._1)) }

    val startBlock = cfg
      .flatMap { case (a, b) => Seq(a, b) }
      .find(!predecessor.contains(_))
      .get

    val successor = cfg.groupBy(_._1).map { case (k, v) => (k, v.map(_._2)) }
    val sortedControls = mutable.LinkedHashSet.empty[SSA.Control]

    def sortBlocks(block: SSA.Control): Unit = if (!sortedControls(block)) {
      sortedControls.add(block)
      for (s <- successor.getOrElse(block, Nil)) sortBlocks(s)
    }

    sortBlocks(startBlock)
    sortedControls
  }


  def rec(ssa: SSA.Val, savedLocals: Map[SSA.Val, Int]): Seq[AbstractInsnNode] = {
    if (savedLocals.contains(ssa)) Seq(new VarInsnNode(loadOp(ssa), savedLocals(ssa)))
    else generateValBytecode(ssa, savedLocals)
  }

  def generateJumpBytecode(ssa: SSA.Jump,
                           savedLocals: Map[SSA.Val, Int],
                           jumpLabel: SSA.Control => LabelNode,
                           fallthroughLabel: SSA.Control => Option[LabelNode]): Seq[AbstractInsnNode] = {
    val upstreams = ssa.upstreamVals.flatMap(rec(_, savedLocals))
    val current: Seq[AbstractInsnNode] = ssa match{
      case n @ SSA.UnaBranch(block, a, opcode) =>
        val goto = fallthroughLabel(n).map(new JumpInsnNode(GOTO, _))
        val jump = Seq(new JumpInsnNode(opcode.i, jumpLabel(n)))
        jump ++ goto

      case n @ SSA.BinBranch(block, a, b, opcode) =>
        val goto = fallthroughLabel(n).map(new JumpInsnNode(GOTO, _))
        val jump = Seq(new JumpInsnNode(opcode.i, jumpLabel(n)))
        jump ++ goto
      case SSA.ReturnVal(state, block, a) => Seq(new InsnNode(returnOp(a)))

      case SSA.Return(state, block) => Seq(new InsnNode(RETURN))
      case SSA.AThrow(state, _, src) => Seq(new InsnNode(ATHROW))
      case SSA.TableSwitch(state, _, src, min, max) => ???
      case SSA.LookupSwitch(state, _, src, keys) => ???
    }

    upstreams ++ current

  }

  def generateValBytecode(ssa: SSA.Val, savedLocals: Map[SSA.Val, Int]): Seq[AbstractInsnNode] = {
    if (ssa.isInstanceOf[SSA.Phi]) Nil
    else {
      val upstreams = ssa.upstreamVals.flatMap(rec(_, savedLocals))
      val current: Seq[AbstractInsnNode] = ssa match{
        case _: SSA.State => Nil
        case _: SSA.Copy => Nil

        case _: SSA.Phi => Nil
        case SSA.Arg(index, typeSize) => Nil
        case SSA.BinOp(a, b, opcode) => Seq(new InsnNode(opcode.i))
        case SSA.UnaOp(a, opcode) => Seq(new InsnNode(opcode.i))
        case SSA.CheckCast(src, desc) => ???
        case SSA.ArrayLength(src) => ???
        case SSA.InstanceOf(src, desc) => ???
        case SSA.PushI(value) => Seq(value match{
          case -1 => new InsnNode(ICONST_M1)
          case 0 => new InsnNode(ICONST_0)
          case 1 => new InsnNode(ICONST_1)
          case 2 => new InsnNode(ICONST_2)
          case 3 => new InsnNode(ICONST_3)
          case 4 => new InsnNode(ICONST_4)
          case 5 => new InsnNode(ICONST_5)
          case _ =>
            if (-128 <= value && value < 127) new IntInsnNode(BIPUSH, value)
            else if (-32768 <= value && value <= 32767) new IntInsnNode(SIPUSH, value)
            else new LdcInsnNode(value)
        })
        case SSA.PushJ(value) => Seq(value match{
          case 0 => new InsnNode(LCONST_0)
          case 1 => new InsnNode(LCONST_1)
          case _ => new LdcInsnNode(value)
        })
        case SSA.PushF(value) => Seq(value match{
          case 0 => new InsnNode(FCONST_0)
          case 1 => new InsnNode(FCONST_1)
          case 2 => new InsnNode(FCONST_2)
          case _ => new LdcInsnNode(value)
        })
        case SSA.PushD(value) => Seq(value match{
          case 0 => new InsnNode(DCONST_0)
          case 1 => new InsnNode(DCONST_1)
          case _ => new LdcInsnNode(value)
        })
        case SSA.PushS(value) => Seq(new LdcInsnNode(value))
        case SSA.PushNull() => Seq(new InsnNode(ACONST_NULL))
        case SSA.PushCls(value) =>
          Seq(new LdcInsnNode(org.objectweb.asm.Type.getType(value.name)))
        case SSA.InvokeStatic(srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
        case SSA.InvokeSpecial(srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
        case SSA.InvokeVirtual(srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
        case SSA.InvokeDynamic(name, desc, bsTag, bsOwner, bsName, bsDesc, bsArgs) => ???
        case SSA.New(cls) => ???
        case SSA.NewArray(src, typeRef) =>
          Seq(
            typeRef match {
              case JType.Arr(JType.Prim.Z) => new IntInsnNode(NEWARRAY, T_BOOLEAN)
              case JType.Arr(JType.Prim.C) => new IntInsnNode(NEWARRAY, T_CHAR)
              case JType.Arr(JType.Prim.B) => new IntInsnNode(NEWARRAY, T_BYTE)
              case JType.Arr(JType.Prim.S) => new IntInsnNode(NEWARRAY, T_SHORT)
              case JType.Arr(JType.Prim.I) => new IntInsnNode(NEWARRAY, T_INT)
              case JType.Arr(JType.Prim.F) => new IntInsnNode(NEWARRAY, T_FLOAT)
              case JType.Arr(JType.Prim.D) => new IntInsnNode(NEWARRAY, T_DOUBLE)
              case JType.Arr(JType.Prim.J) => new IntInsnNode(NEWARRAY, T_LONG)
              case t => new TypeInsnNode(ANEWARRAY, t.name)
            }
          )
        case SSA.MultiANewArray(desc, dims) =>
          Seq(new MultiANewArrayInsnNode(desc.name, dims.length))
        case SSA.PutStatic(_, src, cls, name, desc) => ???
        case SSA.GetStatic(_, cls, name, desc) => ???
        case SSA.PutField(_, src, obj, owner, name, desc) => ???
        case SSA.GetField(_, obj, owner, name, desc) => ???
        case SSA.PutArray(_, array, indexSrc, src) =>
          pprint.log(src.jtype)
          pprint.log(src)
          pprint.log(array)
          Seq(new InsnNode(
            src.jtype match {
              case JType.Prim.Z => IASTORE
              case JType.Prim.C => CASTORE
              case JType.Prim.B => BASTORE
              case JType.Prim.S => SASTORE
              case JType.Prim.I => IASTORE
              case JType.Prim.F => FASTORE
              case JType.Prim.D => DASTORE
              case JType.Prim.J => LASTORE
              case t => AASTORE
            }
          ))
        case SSA.GetArray(_, indexSrc, array, tpe) =>
          Seq(new InsnNode(
            tpe match {
              case JType.Prim.Z => IALOAD
              case JType.Prim.C => CALOAD
              case JType.Prim.B => BALOAD
              case JType.Prim.S => SALOAD
              case JType.Prim.I => IALOAD
              case JType.Prim.F => FALOAD
              case JType.Prim.D => DALOAD
              case JType.Prim.J => LALOAD
              case t => AALOAD
            }
          ))
        case SSA.MonitorEnter(indexSrc) => ???
        case SSA.MonitorExit(indexSrc) => ???
      }

      val save = ssa match{
        case n: SSA.Val if savedLocals.contains(n) && n.getSize > 0 =>
          Seq(new VarInsnNode(saveOp(n), savedLocals(n)))
        case _ => Nil
      }

      upstreams ++ current ++ save

    }
  }

  def loadOp(ssa: SSA.Val) = {
    ssa.jtype match {
      case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => ILOAD
      case JType.Prim.J => LLOAD
      case JType.Prim.F => FLOAD
      case JType.Prim.D => DLOAD
      case _ => ALOAD
    }
  }

  def saveOp(n: SSA.Val) = {
    n.jtype match {
      case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => ISTORE
      case JType.Prim.J => LSTORE
      case JType.Prim.F => FSTORE
      case JType.Prim.D => DSTORE
      case _ => ASTORE
    }
  }

  def returnOp(a: SSA.Val) = {
    a.jtype match {
      case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => IRETURN
      case JType.Prim.J => LRETURN
      case JType.Prim.F => FRETURN
      case JType.Prim.D => DRETURN
      case _ => ARETURN
    }
  }
}
