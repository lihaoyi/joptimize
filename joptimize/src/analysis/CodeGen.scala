package joptimize.analysis

import java.util

import joptimize.Util
import joptimize.model.{Program, SSA}
import org.objectweb.asm.Opcodes._
import org.objectweb.asm.tree._

import collection.JavaConverters._
import scala.collection.mutable

/**
  * Converts the hybrid dataflow/controlflow graph generated by the Walker
  * back into executable bytecode, without all the unreachable, unused or
  * constant-folded instructions
  */

object CodeGen{
  def renderGraph(edges: Seq[(fansi.Str, fansi.Str)]): fansi.Str = {
    val allStrings = edges.flatMap(x => Seq(x._1, x._2)).distinct
    val stringToIndex = allStrings.zipWithIndex.toMap
    val indexToString = stringToIndex.map(_.swap)
    val edgeGroups = edges.groupBy(_._2).map{case (k, v) => (k, v.map(_._1))}
    val sorted = Tarjans(allStrings.map(edgeGroups.getOrElse(_, Nil).map(stringToIndex))).flatten
    val out = mutable.Buffer.empty[fansi.Str]

    for(i <- sorted){
      val dest = allStrings(i)
      val srcs = edgeGroups.getOrElse(dest, Nil)
      out.append(dest, " <- ")
      out.append(srcs.flatMap(src => Seq(fansi.Str(", "), src)).drop(1):_*)
      out.append("\n")
    }
    fansi.Str.join(out:_*)
  }

  def findCtrl(ssa: SSA) = ssa match{
    case SSA.Return(ctrl) => ctrl
    case SSA.ReturnVal(ctrl, _) => ctrl
    case SSA.UnaBranch(ctrl, _, _) => ctrl
    case SSA.BinBranch(ctrl, _, _, _) => ctrl
  }

  def findControlFlowGraph(program: Program) = {
    val controlFlowEdges = mutable.Buffer.empty[(SSA.Control, SSA.Control)]
    val visited = mutable.Set.empty[SSA.Control]

    def rec(start: SSA.Control): Unit = if (!visited(start)){
      visited.add(start)

      val upstreams = start match{
        case SSA.True(x) => Seq(findCtrl(x))
        case SSA.False(x) => Seq(findCtrl(x))
        case r: SSA.Region => program.regionMerges(r)
      }

      for(control <- upstreams){
        rec(control)
        controlFlowEdges.append(control -> start)
      }
    }

    program.allTerminals.foreach(x => rec(findCtrl(x)))
    controlFlowEdges
  }


  def apply(program: Program, mapping: Map[SSA.Token, String]): InsnList = {
    val controlFlowEdges = findControlFlowGraph(program)

    val graph = controlFlowEdges ++ program.allTerminals.map{ case r: SSA.Controlled => (r.control, r)}
    println(
      renderGraph(
        graph.map{
          case (l: SSA.Control, r: SSA.Controlled) => (fansi.Color.Cyan(mapping(l)), fansi.Color.Yellow("return"))
          case (l: SSA.Control, r: SSA.Control) => (fansi.Color.Cyan(mapping(l)), fansi.Color.Cyan(mapping(r)))
        }
      )
    )

    val loopTree = LoopFinder.analyzeLoops(graph)

    def rec(l: LoopFinder.Loop[SSA.Token], depth: Int, label0: List[Int]): Unit = {
      val indent = "    " * depth
      val id = label0.reverseIterator.map("-" + _).mkString
      val reducible = if (l.isReducible) "" else " (Irreducible)"
      val header = l.headers.map(mapping).mkString("[", ", ", "]")
      val blockStr = l.basicBlocks.filter(!l.headers(_)).map(x => mapping(x)).mkString("[", ", ", "]")
      println(s"${indent}loop$id$reducible, header: $header, blocks: $blockStr")

      for((c, i) <- l.children.zipWithIndex)rec(c, depth + 1, i :: label0)
    }

    rec(loopTree, 0, Nil)

    val (immediateDominators, dominatorDepth) = findDominators(graph)

    val nodesToBlocks = schedule(program, loopTree, dominatorDepth, immediateDominators, graph, mapping)
    pprint.log(nodesToBlocks, height=99999)
//    val pinnedNodes = program
//    for(controlFlow)
    ???
  }

  def schedule(program: Program,
               loopTree: LoopFinder.Loop[SSA.Token],
               dominatorDepth: Map[SSA.Token, Int],
               immediateDominator: Map[SSA.Token, SSA.Token],
               graph: Seq[(SSA.Token, SSA.Token)],
               mapping: Map[SSA.Token, String]): Map[SSA.Token, SSA.Token] = {
    val (allVertices, roots, downstreamEdges) =
      Util.breadthFirstAggregation[SSA.Token](program.allTerminals.toSet){
        case ctrl: SSA.Region => program.regionMerges(ctrl).toSeq
        case SSA.True(inner) => Seq(inner)
        case SSA.False(inner) => Seq(inner)

        case ssa: SSA =>
          ssa.allUpstream ++ (ssa match{
            case phi: SSA.Phi => program.phiMerges(phi)._2.flatMap(x => Seq(x._1, x._2))
            case _ => Nil
          })
      }
    val loopNestMap = mutable.Map.empty[SSA.Token, Int]
    def recLoop(loop: LoopFinder.Loop[SSA.Token], depth: Int): Unit = {
      loop.basicBlocks.foreach(loopNestMap(_) = depth)
      loop.children.foreach(recLoop(_, depth + 1))
    }
    recLoop(loopTree, 0)

    val downstreamMap = downstreamEdges.groupBy(_._1).map{case (k, vs) => (k, vs.map(_._2))}
    val upstreamMap = downstreamEdges.groupBy(_._2).map{case (k, vs) => (k, vs.map(_._1))}
    val scheduler = new Scheduler(dominatorDepth, immediateDominator, program.phiMerges, mapping) {
      override def downstream(ssa: SSA.Token) = downstreamMap.getOrElse(ssa, Nil)

      override def upstream(ssa: SSA.Token) = upstreamMap.getOrElse(ssa, Nil).filter(!_.isInstanceOf[SSA.Control])

      override def isPinned(ssa: SSA.Token) = ssa.isInstanceOf[SSA.Controlled] || ssa.isInstanceOf[SSA.Control]

      override def loopNest(block: SSA.Token) = {
        assert(block != null)
        loopNestMap(block)
      }
    }

    val startControl = (graph.map(_._1).toSet -- graph.map(_._2)).head
    allVertices.collect{
      case c: SSA.Control => scheduler.control(c) = c
      case c: SSA.Controlled => scheduler.control(c) = c.control
      case c: SSA.Phi => scheduler.control(c) = program.phiMerges(c)._1
      case c: SSA.Arg => scheduler.control(c) = startControl
      case c: SSA.PushCls => scheduler.control(c) = startControl
      case c: SSA.PushD => scheduler.control(c) = startControl
      case c: SSA.PushF => scheduler.control(c) = startControl
      case c: SSA.PushI => scheduler.control(c) = startControl
      case c: SSA.PushJ => scheduler.control(c) = startControl
      case c: SSA.PushNull => scheduler.control(c) = startControl
      case c: SSA.PushS => scheduler.control(c) = startControl
    }

    allVertices.collect{
      case scheduleRoot: SSA.Phi =>
        pprint.log(scheduleRoot)
        scheduler.scheduleEarly(scheduleRoot)
      case scheduleRoot: SSA.Control =>
        pprint.log(scheduleRoot)
        scheduler.scheduleEarly(scheduleRoot)
      case scheduleRoot: SSA.Controlled =>
        pprint.log(scheduleRoot)
        scheduler.scheduleEarly(scheduleRoot)
    }

    pprint.log(scheduler.control, height=9999)

    allVertices.collect{
      case scheduleRoot: SSA.Control =>
        pprint.log(scheduleRoot)
        scheduler.scheduleLate(scheduleRoot)
      case scheduleRoot: SSA.Controlled =>
        pprint.log(scheduleRoot)
        scheduler.scheduleLate(scheduleRoot)
    }

    scheduler.control.filter{case (k, v) => v != null}.toMap
  }

  def findDominators[T](edges: Seq[(T, T)]): (Map[T, T], Map[T, Int]) = {
    val indices = edges.flatMap{case (x, y) => Seq(x, y)}.distinct.zipWithIndex.toMap
    val nodes = indices.map(_.swap)
    val successorMap = edges.groupBy(_._1).map{case (k, v) => (indices(k), v.map(_._2).map(indices))}
    val predecessorMap = edges.groupBy(_._2).map{case (k, v) => (indices(k), v.map(_._1).map(indices))}

    val immediateDominators = new LengauerTarjan {
      def successors(v: Int) = successorMap.getOrElse(v, Nil)
      def predecessors(v: Int) = predecessorMap.getOrElse(v, Nil)
      def numNodes = indices.size
    }.computeDominatorTree()

    val dominatorDepth = {
      Array.tabulate(immediateDominators.length) { i =>
        var current = i
        var n = 0
        while (immediateDominators(current) != -1){
          current = immediateDominators(current)
          n += 1
        }
        n
      }
    }
    (
      immediateDominators.zipWithIndex.collect{case (v, i) if v != -1 => (nodes(i), nodes(v))}.toMap,
      dominatorDepth.zipWithIndex.map{case (v, i) => (nodes(i), v)}.toMap
    )
  }
}
//object CodeGen {
//
//  def apply(allVisitedBlocks: Seq[Walker.BlockResult],
//            merges: Seq[(Frame[SSA], Frame[SSA])],
//            initialArgs: Seq[SSA.Arg],
//            inferredTypes: util.IdentityHashMap[SSA, IType]): (InsnList, Set[Int]) = {
//    val allTerminals = allVisitedBlocks.flatMap(_.terminalInsns)
//    val subCallArgLiveness = allVisitedBlocks.flatMap(_.subCallArgLiveness).toMap
//    val mergeLookup = mutable.Map.empty[SSA, mutable.Buffer[SSA]]
//
//    for((lhs, rhs) <- merges){
//      lhs.zipForeach(rhs){(l, r) =>
//        mergeLookup.getOrElseUpdate(l, mutable.Buffer()) += r
//      }
//    }
//
//    val (allVertices, roots, downstreamEdges) =
//      Util.breadthFirstAggregation[SSA](allTerminals.toSet){ ssa =>
//        ssa.upstream ++ mergeLookup.getOrElse(ssa, Nil)
//      }
//
//    val saveable = downstreamEdges
//      .groupBy(_._1)
//      .map{
//        case (k: SSA.PushI, _) => (k, false)
//        case (k: SSA.PushJ, _) => (k, false)
//        case (k: SSA.PushF, _) => (k, false)
//        case (k: SSA.PushD, _) => (k, false)
//        case (k: SSA.PushS, _) => (k, false)
//        case (k: SSA.PushNull, _) => (k, false)
//        case (k: SSA.PushCls, _) => (k, false)
//        case (k, x) =>
//          val n = x.distinct.size
//          (k, n > 1 || n == 1 && allTerminals.contains(k))
//      }
//
//    val liveArgumentIndices = for{
//      (a, i) <- initialArgs.zipWithIndex
//      if roots(a)
//    } yield i
//
//
//    val savedLocals = new util.IdentityHashMap[SSA, Int]()
//    for((a, i) <- initialArgs.zipWithIndex){
//      savedLocals.put(a, i)
//    }
//    val startLabels = allVisitedBlocks.map(_.blockInsns -> new LabelNode()).toMap
//
//    val blockInsns: Seq[Seq[AbstractInsnNode]] = for((block, blockIndex) <- allVisitedBlocks.zipWithIndex) yield {
//      def rec(ssa: SSA): Seq[AbstractInsnNode] = {
//        if (savedLocals.containsKey(ssa)){
//          Seq(
//            new VarInsnNode(
//              inferredTypes.get(ssa).widen match{
//                case JType.Prim.I => ILOAD
//                case JType.Prim.J => LLOAD
//                case JType.Prim.F => FLOAD
//                case JType.Prim.D => DLOAD
//                case _ => ALOAD
//              },
//              savedLocals.get(ssa)
//            )
//          )
//        }else{
//          val upstreams = ssa.upstream.flatMap(rec)
//          val current: Seq[AbstractInsnNode] = ssa match{
//            case SSA.Arg(index, typeSize) => ??? // shouldn't happen
//            case SSA.BinOp(a, b, opcode) => Seq(new InsnNode(opcode.i))
//            case SSA.UnaryOp(a, opcode) => Seq(new InsnNode(opcode.i))
//            case SSA.UnaryBranch(a, target, opcode) =>
//              Seq(new JumpInsnNode(opcode.i, startLabels(target)))
//            case SSA.BinBranch(a, b, target, opcode) =>
//              Seq(new JumpInsnNode(opcode.i, startLabels(target)))
//            case SSA.ReturnVal(a) =>
//              Seq(new InsnNode(
//                inferredTypes.get(a).widen match{
//                  case JType.Prim.I | JType.Prim.B | JType.Prim.S | JType.Prim.C => IRETURN
//                  case JType.Prim.J => LRETURN
//                  case JType.Prim.F => FRETURN
//                  case JType.Prim.D => DRETURN
//                  case _ => ARETURN
//                }
//              ))
//
//            case SSA.Return() => Seq(new InsnNode(RETURN))
//            case SSA.AThrow(src) => Seq(new InsnNode(ATHROW))
//            case SSA.TableSwitch(src, min, max, default, targets) => ???
//            case SSA.LookupSwitch(src, default, keys, targets) => ???
//            case SSA.Goto(target) => ???
//            case SSA.CheckCast(src, desc) => ???
//            case SSA.ArrayLength(src) => ???
//            case SSA.InstanceOf(src, desc) => ???
//            case SSA.PushI(value) => Seq(value match{
//              case -1 => new InsnNode(ICONST_M1)
//              case 0 => new InsnNode(ICONST_0)
//              case 1 => new InsnNode(ICONST_1)
//              case 2 => new InsnNode(ICONST_2)
//              case 3 => new InsnNode(ICONST_3)
//              case 4 => new InsnNode(ICONST_4)
//              case 5 => new InsnNode(ICONST_5)
//              case _ =>
//                if (-128 <= value && value < 127) new IntInsnNode(BIPUSH, value)
//                else if (-32768 <= value && value <= 32767) new IntInsnNode(BIPUSH, value)
//                else new LdcInsnNode(value)
//            })
//            case SSA.PushJ(value) => Seq(value match{
//              case 0 => new InsnNode(LCONST_0)
//              case 1 => new InsnNode(LCONST_1)
//              case _ => new LdcInsnNode(value)
//            })
//            case SSA.PushF(value) => Seq(value match{
//              case 0 => new InsnNode(FCONST_0)
//              case 1 => new InsnNode(FCONST_1)
//              case 2 => new InsnNode(FCONST_2)
//              case _ => new LdcInsnNode(value)
//            })
//            case SSA.PushD(value) => Seq(value match{
//              case 0 => new InsnNode(DCONST_0)
//              case 1 => new InsnNode(DCONST_1)
//              case _ => new LdcInsnNode(value)
//            })
//            case SSA.PushS(value) => Seq(new LdcInsnNode(value))
//            case SSA.PushNull() => Seq(new InsnNode(ACONST_NULL))
//            case SSA.PushCls(value) =>
//              Seq(new LdcInsnNode(org.objectweb.asm.Type.getType(value.name)))
//            case SSA.InvokeStatic(state, srcs, cls, name, desc) =>
//              srcs.flatMap(rec) ++
//              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
//            case SSA.InvokeSpecial(state, srcs, cls, name, desc) =>
//              srcs.flatMap(rec) ++
//              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
//            case SSA.InvokeVirtual(state, srcs, cls, name, desc) =>
//              srcs.flatMap(rec) ++
//              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
//            case SSA.InvokeDynamic(name, desc, bsTag, bsOwner, bsName, bsDesc, bsArgs) => ???
//            case SSA.New(cls) => ???
//            case SSA.NewArray(src, typeRef) => ???
//            case SSA.MultiANewArray(desc, dims) => ???
//            case SSA.PutStatic(state, src, cls, name, desc) => ???
//            case SSA.GetStatic(state, cls, name, desc) => ???
//            case SSA.PutField(state, src, obj, owner, name, desc) => ???
//            case SSA.GetField(state, obj, owner, name, desc) => ???
//            case SSA.PutArray(state, src, indexSrc, array) => ???
//            case SSA.GetArray(state, indexSrc, array, typeSize) => ???
//            case SSA.MonitorEnter(indexSrc) => ???
//            case SSA.MonitorExit(indexSrc) => ???
//          }
//          val save =
//            if (!saveable.getOrElse(ssa, false)) Nil
//            else {
//              val n = savedLocals.size()
//              val res = Seq(
//                new InsnNode(DUP),
//                new VarInsnNode(
//                  inferredTypes.get(ssa).widen match{
//                    case JType.Prim.I => ISTORE
//                    case JType.Prim.J => LSTORE
//                    case JType.Prim.F => FSTORE
//                    case JType.Prim.D => DSTORE
//                    case _ => ASTORE
//                  },
//                  n
//                )
//              )
//              savedLocals.put(ssa, n)
//              res
//            }
//
//          upstreams ++ current ++ save
//        }
//      }
//
//      val renderRoots = block.blockInsns.value.filter(i => block.terminalInsns.contains(i) || saveable.getOrElse(i, false))
//      Seq(startLabels(block.blockInsns)) ++ renderRoots.flatMap(rec)
//    }
//    val outputInsns = new InsnList()
//    blockInsns.flatten.foreach(outputInsns.add)
//
//    (outputInsns, liveArgumentIndices.toSet)
//  }
//}
//
//
