package joptimize.analysis

import java.util

import joptimize.Util
import joptimize.graph.{LengauerTarjanDominatorTree, HavlakLoopTree, TarjansStronglyConnectedComponents}
import joptimize.model.{Program, SSA}
import org.objectweb.asm.Opcodes._
import org.objectweb.asm.tree._

import collection.JavaConverters._
import scala.collection.mutable

/**
  * Converts the hybrid dataflow/controlflow graph generated by the Walker
  * back into executable bytecode, without all the unreachable, unused or
  * constant-folded instructions
  */

object CodeGen{
  def findControlFlowGraph(program: Program) = {
    val controlFlowEdges = mutable.Buffer.empty[(SSA.Ctrl, SSA.Ctrl)]
    val visited = mutable.LinkedHashSet.empty[SSA.Ctrl]

    def rec(current: SSA.Ctrl): Unit = if (!visited(current)){
      visited.add(current)

      val upstreams = current match{
        case n: SSA.True => Seq(n.node)
        case n: SSA.False => Seq(n.node)
        case n: SSA.UnaBranch => Seq(n.control)
        case n: SSA.BinBranch => Seq(n.control)
        case n: SSA.Return => Seq(n.control)
        case n: SSA.ReturnVal => Seq(n.control)
        case r: SSA.Region => r.incoming
      }

      for(control <- upstreams){
        rec(control)
        controlFlowEdges.append(control -> current)
      }
    }

    program.allTerminals.foreach(rec)
    controlFlowEdges
  }


  def apply(program: Program, mapping: Map[SSA.Node, String]): InsnList = {
    val controlFlowEdges = findControlFlowGraph(program)


    println(
      Renderer.renderGraph(
        controlFlowEdges.map{
//          case (l: SSA.Ctrl, r: SSA.Controlled) => (fansi.Color.Cyan(mapping(l)), fansi.Color.Yellow("return"))
          case (l: SSA.Ctrl, r: SSA.Ctrl) => (l, r)
        },
        l => fansi.Color.Magenta(mapping(l))
      )
    )

    val loopTree = HavlakLoopTree.analyzeLoops(controlFlowEdges)

    def rec(l: HavlakLoopTree.Loop[SSA.Ctrl], depth: Int, label0: List[Int]): Unit = {
      val indent = "    " * depth
      val id = label0.reverseIterator.map("-" + _).mkString
      val reducible = if (l.isReducible) "" else " (Irreducible)"
      val header = mapping(l.primaryHeader)
      val blockStr = l.basicBlocks.filter(_ != l.primaryHeader).map(x => mapping(x)).mkString("[", ", ", "]")
      println(s"${indent}loop$id$reducible, header: $header, blocks: $blockStr")

      for((c, i) <- l.children.zipWithIndex)rec(c, depth + 1, i :: label0)
    }

    rec(loopTree, 0, Nil)

    val (immediateDominators, dominatorDepth) = findDominators(controlFlowEdges)

    pprint.log(dominatorDepth.map{case (k, v) => (mapping(k), v)})
    pprint.log(immediateDominators.map{case (k, v) => (mapping(k), mapping(v))})
    pprint.log(immediateDominators)
    val nodesToBlocks = schedule(
      program, loopTree,
      dominatorDepth, immediateDominators,
      controlFlowEdges, mapping
    )
    val prettyNodesToBlocks = nodesToBlocks.collect{case (k, v) if mapping.contains(k) => (mapping(k), mapping(v))}
    pprint.log(prettyNodesToBlocks, height=99999)
    println(Renderer.renderSSA(program, nodesToBlocks)._1)
//    val pinnedNodes = program
//    for(controlFlow)
    ???
  }

  def schedule(program: Program,
               loopTree: HavlakLoopTree.Loop[SSA.Ctrl],
               dominatorDepth: Map[SSA.Ctrl, Int],
               immediateDominator: Map[SSA.Ctrl, SSA.Ctrl],
               graph: Seq[(SSA.Ctrl, SSA.Ctrl)],
               mapping: Map[SSA.Node, String]): Map[SSA.Val, SSA.Ctrl] = {
    val (allVertices, roots, downstreamEdges) =
      Util.breadthFirstAggregation[SSA.Node](program.allTerminals.toSet)(_.upstream)
    val loopNestMap = mutable.LinkedHashMap.empty[SSA.Node, Int]
    def recLoop(loop: HavlakLoopTree.Loop[SSA.Ctrl], depth: Int): Unit = {
      loop.basicBlocks.foreach(loopNestMap(_) = depth)
      loop.children.foreach(recLoop(_, depth + 1))
    }

    recLoop(loopTree, 0)

    val downstreamMap = downstreamEdges.groupBy(_._1).map{case (k, vs) => (k, vs.map(_._2))}
    val upstreamMap = downstreamEdges.groupBy(_._2).map{case (k, vs) => (k, vs.map(_._1))}
    val scheduler = new ClickScheduler(dominatorDepth, immediateDominator, mapping) {
      override def downstream(ssa: SSA.Node) = downstreamMap.getOrElse(ssa, Nil)

      override def upstream(ssa: SSA.Node) = upstreamMap.getOrElse(ssa, Nil).collect{case ssa: SSA.Val => ssa}

      override def isPinned(ssa: SSA.Node) = ssa.isInstanceOf[SSA.Ctrl]

      override def loopNest(block: SSA.Node) = {
        assert(block != null)
        loopNestMap(block)
      }
    }

    val startControl = (graph.map(_._1).toSet -- graph.map(_._2)).head
    allVertices.collect{
      case c: SSA.Phi => scheduler.control(c) = c.control
      case c: SSA.Val if c.upstream.isEmpty => scheduler.control(c) = startControl
    }

    allVertices.collect{
      case scheduleRoot: SSA.Phi => scheduler.scheduleEarlyRoot(scheduleRoot)
      case scheduleRoot: SSA.Ctrl => scheduler.scheduleEarlyRoot(scheduleRoot)
    }

    pprint.log(scheduler.control.map{case (k, v) => (k, mapping(v))}, height=9999)

    allVertices.collect{
      case scheduleRoot: SSA.Ctrl => scheduler.scheduleLateRoot(scheduleRoot)
    }

    pprint.log(scheduler.control.map{case (k, v) => (k, mapping(v))}, height=9999)

    scheduler.control.filter{case (k, v) => v != null}.toMap
  }

  def findDominators[T](edges: Seq[(T, T)]): (Map[T, T], Map[T, Int]) = {
    val indices = edges.flatMap{case (x, y) => Seq(x, y)}.distinct.zipWithIndex.toMap
    val nodes = indices.map(_.swap)

    val successorMap = edges.groupBy(_._1).map{case (k, v) => (indices(k), v.map(_._2).map(indices))}
    val predecessorMap = edges.groupBy(_._2).map{case (k, v) => (indices(k), v.map(_._1).map(indices))}

    val immediateDominators = new LengauerTarjanDominatorTree {
      def successors(v: Int) = successorMap.getOrElse(v, Nil)
      def predecessors(v: Int) = predecessorMap.getOrElse(v, Nil)
      def numNodes = indices.size
    }.computeDominatorTree()

    val dominatorDepth = {
      Array.tabulate(immediateDominators.length) { i =>
        var current = i
        var n = 0
        while (immediateDominators(current) != -1){
          current = immediateDominators(current)
          n += 1
        }
        n
      }
    }

    (
      immediateDominators.zipWithIndex.collect{case (v, i) if v != -1 => (nodes(i), nodes(v))}.toMap,
      dominatorDepth.zipWithIndex.map{case (v, i) => (nodes(i), v)}.toMap
    )
  }
}
//object CodeGen {
//
//  def apply(allVisitedBlocks: Seq[Walker.BlockResult],
//            merges: Seq[(Frame[SSA], Frame[SSA])],
//            initialArgs: Seq[SSA.Arg],
//            inferredTypes: util.IdentityHashMap[SSA, IType]): (InsnList, Set[Int]) = {
//    val allTerminals = allVisitedBlocks.flatMap(_.terminalInsns)
//    val subCallArgLiveness = allVisitedBlocks.flatMap(_.subCallArgLiveness).toMap
//    val mergeLookup = mutable.LinkedHashMap.empty[SSA, mutable.Buffer[SSA]]
//
//    for((lhs, rhs) <- merges){
//      lhs.zipForeach(rhs){(l, r) =>
//        mergeLookup.getOrElseUpdate(l, mutable.Buffer()) += r
//      }
//    }
//
//    val (allVertices, roots, downstreamEdges) =
//      Util.breadthFirstAggregation[SSA](allTerminals.toSet){ ssa =>
//        ssa.upstream ++ mergeLookup.getOrElse(ssa, Nil)
//      }
//
//    val saveable = downstreamEdges
//      .groupBy(_._1)
//      .map{
//        case (k: SSA.PushI, _) => (k, false)
//        case (k: SSA.PushJ, _) => (k, false)
//        case (k: SSA.PushF, _) => (k, false)
//        case (k: SSA.PushD, _) => (k, false)
//        case (k: SSA.PushS, _) => (k, false)
//        case (k: SSA.PushNull, _) => (k, false)
//        case (k: SSA.PushCls, _) => (k, false)
//        case (k, x) =>
//          val n = x.distinct.size
//          (k, n > 1 || n == 1 && allTerminals.contains(k))
//      }
//
//    val liveArgumentIndices = for{
//      (a, i) <- initialArgs.zipWithIndex
//      if roots(a)
//    } yield i
//
//
//    val savedLocals = new util.IdentityHashMap[SSA, Int]()
//    for((a, i) <- initialArgs.zipWithIndex){
//      savedLocals.put(a, i)
//    }
//    val startLabels = allVisitedBlocks.map(_.blockInsns -> new LabelNode()).toMap
//
//    val blockInsns: Seq[Seq[AbstractInsnNode]] = for((block, blockIndex) <- allVisitedBlocks.zipWithIndex) yield {
//      def rec(ssa: SSA): Seq[AbstractInsnNode] = {
//        if (savedLocals.containsKey(ssa)){
//          Seq(
//            new VarInsnNode(
//              inferredTypes.get(ssa).widen match{
//                case JType.Prim.I => ILOAD
//                case JType.Prim.J => LLOAD
//                case JType.Prim.F => FLOAD
//                case JType.Prim.D => DLOAD
//                case _ => ALOAD
//              },
//              savedLocals.get(ssa)
//            )
//          )
//        }else{
//          val upstreams = ssa.upstream.flatMap(rec)
//          val current: Seq[AbstractInsnNode] = ssa match{
//            case SSA.Arg(index, typeSize) => ??? // shouldn't happen
//            case SSA.BinOp(a, b, opcode) => Seq(new InsnNode(opcode.i))
//            case SSA.UnaryOp(a, opcode) => Seq(new InsnNode(opcode.i))
//            case SSA.UnaryBranch(a, target, opcode) =>
//              Seq(new JumpInsnNode(opcode.i, startLabels(target)))
//            case SSA.BinBranch(a, b, target, opcode) =>
//              Seq(new JumpInsnNode(opcode.i, startLabels(target)))
//            case SSA.ReturnVal(a) =>
//              Seq(new InsnNode(
//                inferredTypes.get(a).widen match{
//                  case JType.Prim.I | JType.Prim.B | JType.Prim.S | JType.Prim.C => IRETURN
//                  case JType.Prim.J => LRETURN
//                  case JType.Prim.F => FRETURN
//                  case JType.Prim.D => DRETURN
//                  case _ => ARETURN
//                }
//              ))
//
//            case SSA.Return() => Seq(new InsnNode(RETURN))
//            case SSA.AThrow(src) => Seq(new InsnNode(ATHROW))
//            case SSA.TableSwitch(src, min, max, default, targets) => ???
//            case SSA.LookupSwitch(src, default, keys, targets) => ???
//            case SSA.Goto(target) => ???
//            case SSA.CheckCast(src, desc) => ???
//            case SSA.ArrayLength(src) => ???
//            case SSA.InstanceOf(src, desc) => ???
//            case SSA.PushI(value) => Seq(value match{
//              case -1 => new InsnNode(ICONST_M1)
//              case 0 => new InsnNode(ICONST_0)
//              case 1 => new InsnNode(ICONST_1)
//              case 2 => new InsnNode(ICONST_2)
//              case 3 => new InsnNode(ICONST_3)
//              case 4 => new InsnNode(ICONST_4)
//              case 5 => new InsnNode(ICONST_5)
//              case _ =>
//                if (-128 <= value && value < 127) new IntInsnNode(BIPUSH, value)
//                else if (-32768 <= value && value <= 32767) new IntInsnNode(BIPUSH, value)
//                else new LdcInsnNode(value)
//            })
//            case SSA.PushJ(value) => Seq(value match{
//              case 0 => new InsnNode(LCONST_0)
//              case 1 => new InsnNode(LCONST_1)
//              case _ => new LdcInsnNode(value)
//            })
//            case SSA.PushF(value) => Seq(value match{
//              case 0 => new InsnNode(FCONST_0)
//              case 1 => new InsnNode(FCONST_1)
//              case 2 => new InsnNode(FCONST_2)
//              case _ => new LdcInsnNode(value)
//            })
//            case SSA.PushD(value) => Seq(value match{
//              case 0 => new InsnNode(DCONST_0)
//              case 1 => new InsnNode(DCONST_1)
//              case _ => new LdcInsnNode(value)
//            })
//            case SSA.PushS(value) => Seq(new LdcInsnNode(value))
//            case SSA.PushNull() => Seq(new InsnNode(ACONST_NULL))
//            case SSA.PushCls(value) =>
//              Seq(new LdcInsnNode(org.objectweb.asm.Type.getType(value.name)))
//            case SSA.InvokeStatic(state, srcs, cls, name, desc) =>
//              srcs.flatMap(rec) ++
//              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
//            case SSA.InvokeSpecial(state, srcs, cls, name, desc) =>
//              srcs.flatMap(rec) ++
//              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
//            case SSA.InvokeVirtual(state, srcs, cls, name, desc) =>
//              srcs.flatMap(rec) ++
//              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
//            case SSA.InvokeDynamic(name, desc, bsTag, bsOwner, bsName, bsDesc, bsArgs) => ???
//            case SSA.New(cls) => ???
//            case SSA.NewArray(src, typeRef) => ???
//            case SSA.MultiANewArray(desc, dims) => ???
//            case SSA.PutStatic(state, src, cls, name, desc) => ???
//            case SSA.GetStatic(state, cls, name, desc) => ???
//            case SSA.PutField(state, src, obj, owner, name, desc) => ???
//            case SSA.GetField(state, obj, owner, name, desc) => ???
//            case SSA.PutArray(state, src, indexSrc, array) => ???
//            case SSA.GetArray(state, indexSrc, array, typeSize) => ???
//            case SSA.MonitorEnter(indexSrc) => ???
//            case SSA.MonitorExit(indexSrc) => ???
//          }
//          val save =
//            if (!saveable.getOrElse(ssa, false)) Nil
//            else {
//              val n = savedLocals.size()
//              val res = Seq(
//                new InsnNode(DUP),
//                new VarInsnNode(
//                  inferredTypes.get(ssa).widen match{
//                    case JType.Prim.I => ISTORE
//                    case JType.Prim.J => LSTORE
//                    case JType.Prim.F => FSTORE
//                    case JType.Prim.D => DSTORE
//                    case _ => ASTORE
//                  },
//                  n
//                )
//              )
//              savedLocals.put(ssa, n)
//              res
//            }
//
//          upstreams ++ current ++ save
//        }
//      }
//
//      val renderRoots = block.blockInsns.value.filter(i => block.terminalInsns.contains(i) || saveable.getOrElse(i, false))
//      Seq(startLabels(block.blockInsns)) ++ renderRoots.flatMap(rec)
//    }
//    val outputInsns = new InsnList()
//    blockInsns.flatten.foreach(outputInsns.add)
//
//    (outputInsns, liveArgumentIndices.toSet)
//  }
//}
//
//
