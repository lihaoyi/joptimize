package joptimize.analysis


import joptimize.model.JType
import joptimize.model.{Program, SSA}
import org.objectweb.asm.Handle
import org.objectweb.asm.Opcodes._
import org.objectweb.asm.tree._
import org.objectweb.asm.util.{Textifier, TraceMethodVisitor}

import scala.collection.mutable

/**
  * Converts the hybrid dataflow/controlflow graph generated by the Walker
  * back into executable bytecode, without all the unreachable, unused or
  * constant-folded instructions
  */

object CodeGen{
  def apply(program: Program,
            allVertices: Set[SSA.Node],
            nodesToBlocks: Map[SSA.Val, SSA.Block],
            cfg: Seq[(SSA.Control, SSA.Control)],
            naming: Namer.Result) = {
    val blocksToNodes = nodesToBlocks.groupBy(_._2).map{case (k, v) => (k, v.keys)}
    val sortedControls = sortControlFlowGraph(cfg)

    val blockIndices = sortedControls.zipWithIndex.toMap

    val labels = sortedControls.map(_ -> new LabelNode()).toMap
    val savedLocalNumbers = naming.savedLocals.collect{case (k: SSA.Val, v) => (k, v._1)}
    val blockCode = mutable.Buffer.empty[(Seq[AbstractInsnNode], Option[AbstractInsnNode])]
    for(control <- sortedControls){
//      pprint.log(block)
      val insns = mutable.Buffer.empty[AbstractInsnNode]
      insns.append(labels(control))
      control match{
        case jump: SSA.Jump =>
          val code = generateJumpBytecode(
            jump,
            savedLocalNumbers,
            jumpLabel = { srcBlock =>
              labels(srcBlock.downstreamList.collect{case t: SSA.True => t}.head)
            },
            switchLabels = { srcBlock =>
              (
                labels(srcBlock.downstreamList.collect{case t: SSA.Default => t}.head),
                srcBlock.downstreamList.collect{case t: SSA.Case => t}.map(labels),
              )
            },
            fallthroughLabel = {srcBlock =>
              val destination = srcBlock.downstreamList.collect{case t: SSA.False => t}.head
              if (blockIndices(destination) == blockIndices(control) + 1) None
              else Some(labels(destination))
            }
          )

          insns.appendAll(code)
        case block: SSA.Block =>
          val blockNodes = blocksToNodes.getOrElse(block, Nil).toSeq.sortBy(naming.finalOrderingMap)
          for(node <- blockNodes){
            if (naming.savedLocals.contains(node) && !node.isInstanceOf[SSA.Arg]){
              val nodeInsns =
                if (node.isInstanceOf[SSA.ChangedState]) generateStateChangeBytecode(node, savedLocalNumbers)
                else generateValBytecode(node, savedLocalNumbers)

//              val printer = new Textifier
//              val methodPrinter = new TraceMethodVisitor(printer)
//              pprint.log(node)
//              pprint.log(nodeInsns.map(Renderer.prettyprint(_, printer, methodPrinter)))
              insns.appendAll(nodeInsns)
            }
          }
      }

      val downstreamBlocks = control.downstreamList.collect{case b: SSA.Control => b}

      val footer = downstreamBlocks.toSeq match{
        case Seq(d) if blockIndices(d) != blockIndices(control) + 1 => Some(new JumpInsnNode(GOTO, labels(d)))
        case _ => None
      }

      blockCode.append(insns -> footer)
    }

    naming.savedLocals.keysIterator.foreach{
      case phi: SSA.Phi if phi.getSize != 0 =>
        for((k, v) <- phi.incoming){
          val (insns, footer) = blockCode(blockIndices(k))
          val added = rec(v, savedLocalNumbers) ++ Seq(new VarInsnNode(saveOp(phi), savedLocalNumbers(phi)))
          blockCode(blockIndices(k)) = (insns ++ added, footer)
        }
      case _ => //do nothing
    }


    val finalInsns = new InsnList()
    for((insns, footer) <- blockCode){
      insns.foreach(finalInsns.add)
      footer.foreach(finalInsns.add)
    }

    (blockCode, finalInsns)
  }

  def generateStateChangeBytecode(node: SSA.Val, savedLocalNumbers: Map[SSA.Val, Int]) = {
    node.upstream
      .collect { case v: SSA.Val if !savedLocalNumbers.contains(v) =>
        generateValBytecodeSideEffects(v, savedLocalNumbers)
      }
      .flatten
  }

  def sortControlFlowGraph(cfg: Seq[(SSA.Control, SSA.Control)]) = {
    val predecessor = cfg.groupBy(_._2).map { case (k, v) => (k, v.map(_._1)) }

    val startBlock = cfg
      .flatMap { case (a, b) => Seq(a, b) }
      .find(!predecessor.contains(_))
      .get

    val successor = cfg.groupBy(_._1).map { case (k, v) => (k, v.map(_._2)) }
    val sortedControls = mutable.LinkedHashSet.empty[SSA.Control]

    def sortBlocks(block: SSA.Control): Unit = if (!sortedControls(block)) {
      sortedControls.add(block)
      for (s <- successor.getOrElse(block, Nil)) sortBlocks(s)
    }

    sortBlocks(startBlock)
    sortedControls
  }


  def rec(ssa: SSA.Val, savedLocals: Map[SSA.Val, Int]): Seq[AbstractInsnNode] = {
    if (ssa.isInstanceOf[SSA.ChangedState]) generateStateChangeBytecode(ssa, savedLocals)
    else if (ssa.isInstanceOf[SSA.Phi] && ssa.getSize == 0) Nil
    else if (savedLocals.contains(ssa)) Seq(new VarInsnNode(loadOp(ssa), savedLocals(ssa)))
    else generateValBytecode(ssa, savedLocals)
  }

  def generateJumpBytecode(ssa: SSA.Jump,
                           savedLocals: Map[SSA.Val, Int],
                           jumpLabel: SSA.Control => LabelNode,
                           switchLabels: SSA.Control => (LabelNode, Seq[LabelNode]),
                           fallthroughLabel: SSA.Control => Option[LabelNode]): Seq[AbstractInsnNode] = {
    val upstreams = ssa.upstreamVals.flatMap(rec(_, savedLocals))
    val current: Seq[AbstractInsnNode] = ssa match{
      case n @ SSA.UnaBranch(block, a, opcode) =>
        val goto = fallthroughLabel(n).map(new JumpInsnNode(GOTO, _))
        val jump = Seq(new JumpInsnNode(opcode.i, jumpLabel(n)))
        jump ++ goto

      case n @ SSA.BinBranch(block, a, b, opcode) =>
        val goto = fallthroughLabel(n).map(new JumpInsnNode(GOTO, _))
        val jump = Seq(new JumpInsnNode(opcode.i, jumpLabel(n)))
        jump ++ goto
      case SSA.ReturnVal(state, block, a) => Seq(new InsnNode(returnOp(a)))

      case SSA.Return(state, block) => Seq(new InsnNode(RETURN))
      case SSA.AThrow(state, _, src) => Seq(new InsnNode(ATHROW))
      case n @ SSA.TableSwitch(_, src, min, max) =>
        val (default, labels) = switchLabels(n)
        Seq(new TableSwitchInsnNode(min, max, default, labels.toArray:_*))
      case n @ SSA.LookupSwitch(_, src, keys) =>
        val (default, labels) = switchLabels(n)
        Seq(new LookupSwitchInsnNode(default, keys.toArray, labels.toArray))
    }

    upstreams ++ current

  }

  def generateValBytecode(ssa: SSA.Val, savedLocals: Map[SSA.Val, Int]): Seq[AbstractInsnNode] = {
    if (ssa.isInstanceOf[SSA.Phi]) Nil
    else {
      val upstreams = ssa.upstreamVals.flatMap(rec(_, savedLocals))
      val current: Seq[AbstractInsnNode] = ssa match{
        case _: SSA.ChangedState => Nil
        case _: SSA.Copy => Nil

        case _: SSA.Phi => Nil
        case SSA.Arg(index, typeSize) => Nil
        case SSA.BinOp(stateOpt, a, b, opcode) => Seq(new InsnNode(opcode.i))
        case SSA.UnaOp(a, opcode) => Seq(new InsnNode(opcode.i))
        case SSA.CheckCast(state, src, desc) => Seq(new TypeInsnNode(CHECKCAST, desc.name))
        case SSA.ArrayLength(state, src) => Seq(new InsnNode(ARRAYLENGTH))
        case SSA.InstanceOf(src, desc) => Seq(new TypeInsnNode(INSTANCEOF, desc.name))
        case SSA.ConstI(value) => Seq(value match{
          case -1 => new InsnNode(ICONST_M1)
          case 0 => new InsnNode(ICONST_0)
          case 1 => new InsnNode(ICONST_1)
          case 2 => new InsnNode(ICONST_2)
          case 3 => new InsnNode(ICONST_3)
          case 4 => new InsnNode(ICONST_4)
          case 5 => new InsnNode(ICONST_5)
          case _ =>
            if (-128 <= value && value < 127) new IntInsnNode(BIPUSH, value)
            else if (-32768 <= value && value <= 32767) new IntInsnNode(SIPUSH, value)
            else new LdcInsnNode(value)
        })
        case SSA.ConstJ(value) => Seq(value match{
          case 0 => new InsnNode(LCONST_0)
          case 1 => new InsnNode(LCONST_1)
          case _ => new LdcInsnNode(value)
        })
        case SSA.ConstF(value) => Seq(value match{
          case 0 => new InsnNode(FCONST_0)
          case 1 => new InsnNode(FCONST_1)
          case 2 => new InsnNode(FCONST_2)
          case _ => new LdcInsnNode(value)
        })
        case SSA.ConstD(value) => Seq(value match{
          case 0 => new InsnNode(DCONST_0)
          case 1 => new InsnNode(DCONST_1)
          case _ => new LdcInsnNode(value)
        })
        case SSA.ConstStr(value) => Seq(new LdcInsnNode(value))
        case SSA.ConstNull() => Seq(new InsnNode(ACONST_NULL))
        case SSA.ConstCls(value) =>
          Seq(new LdcInsnNode(org.objectweb.asm.Type.getType(value.name)))
        case SSA.InvokeStatic(state, srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
        case SSA.InvokeSpecial(state, srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKESPECIAL, cls.name, name, desc.unparse))
        case SSA.InvokeVirtual(state, srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKEVIRTUAL, cls.name, name, desc.unparse))
        case SSA.InvokeInterface(state, srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKEINTERFACE, cls.name, name, desc.unparse))
        case SSA.InvokeDynamic(name, desc, bootstrap, bootstrapArgs, vs) =>
          Seq(new InvokeDynamicInsnNode(
            name, desc.unparse,
            new Handle(bootstrap.tag, bootstrap.owner.name, bootstrap.name, bootstrap.desc.unparse),
            bootstrapArgs.map(SSA.InvokeDynamic.argToAny):_*
          ))
        case SSA.New(cls) => Seq(new TypeInsnNode(NEW, cls.name))
        case SSA.NewArray(state, src, typeRef) => Seq(newArrayOp(typeRef))
        case SSA.MultiANewArray(state, desc, dims) => Seq(new MultiANewArrayInsnNode(desc.name, dims.length))
        case SSA.PutStatic(_, src, cls, name, desc) => Seq(new FieldInsnNode(PUTSTATIC, cls.name, name, desc.internalName))
        case SSA.GetStatic(_, cls, name, desc) => Seq(new FieldInsnNode(GETSTATIC, cls.name, name, desc.internalName))
        case SSA.PutField(_, src, obj, owner, name, desc) => Seq(new FieldInsnNode(PUTFIELD, owner.name, name, desc.internalName))
        case SSA.GetField(_, obj, owner, name, desc) => Seq(new FieldInsnNode(GETFIELD, owner.name, name, desc.internalName))
        case SSA.PutArray(_, array, indexSrc, src) => Seq(new InsnNode(arrayStoreOp(src)))
        case SSA.GetArray(_, indexSrc, array, tpe) => Seq(new InsnNode(arrayLoadOp(tpe)))
        case SSA.MonitorEnter(indexSrc) => ???
        case SSA.MonitorExit(indexSrc) => ???
      }

      val save = ssa match{
        case n: SSA.Val if savedLocals.contains(n) && n.getSize > 0 =>
          Seq(new VarInsnNode(saveOp(n), savedLocals(n)))
        case _ => Nil
      }

      upstreams ++ current ++ save

    }
  }


  def generateValBytecodeSideEffects(ssa: SSA.Val, savedLocals: Map[SSA.Val, Int]): Seq[AbstractInsnNode] = {
    if (ssa.isInstanceOf[SSA.Phi]) Nil
    else {
      val upstreams = ssa.upstreamVals.flatMap(rec(_, savedLocals))
      val current: Seq[AbstractInsnNode] = ssa match{
        case _: SSA.State | _: SSA.Copy | _: SSA.Phi | _: SSA.Arg => Nil
        case SSA.BinOp(stateOpt, a, b, opcode) => Seq(new InsnNode(opcode.i), new InsnNode(POP))
        case SSA.UnaOp(a, opcode) => Seq(new InsnNode(opcode.i), new InsnNode(POP))
        case SSA.CheckCast(state, src, desc) => Seq(new TypeInsnNode(CHECKCAST, desc.name), new InsnNode(POP))
        case SSA.ArrayLength(state, src) => Seq(new InsnNode(ARRAYLENGTH), new InsnNode(POP))
        case SSA.InstanceOf(src, desc) => Seq(new TypeInsnNode(INSTANCEOF, desc.name), new InsnNode(POP))
        case _: SSA.ConstI | _: SSA.ConstJ | _: SSA.ConstF | _: SSA.ConstD |
             _: SSA.ConstStr | _: SSA.ConstNull | _: SSA.ConstCls  => Nil

        case SSA.InvokeStatic(state, srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse)) ++
          (if (desc.ret.size == 0) Nil else Seq(new InsnNode(POP)))
        case SSA.InvokeSpecial(state, srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKESPECIAL, cls.name, name, desc.unparse)) ++
          (if (desc.ret.size == 0) Nil else Seq(new InsnNode(POP)))
        case SSA.InvokeVirtual(state, srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKEVIRTUAL, cls.name, name, desc.unparse)) ++
          (if (desc.ret.size == 0) Nil else Seq(new InsnNode(POP)))
        case SSA.InvokeInterface(state, srcs, cls, name, desc) =>
          Seq(new MethodInsnNode(INVOKEINTERFACE, cls.name, name, desc.unparse)) ++
          (if (desc.ret.size == 0) Nil else Seq(new InsnNode(POP)))
        case SSA.InvokeDynamic(name, desc, bootstrap, bootstrapArgs, vs) =>
          Seq(new InvokeDynamicInsnNode(
            name, desc.unparse,
            new Handle(bootstrap.tag, bootstrap.owner.name, bootstrap.name, bootstrap.desc.unparse),
            bootstrapArgs.map(SSA.InvokeDynamic.argToAny):_*
          ))
        case SSA.New(cls) => ???
        case SSA.NewArray(state, src, typeRef) => Seq(newArrayOp(typeRef), new InsnNode(POP))
        case SSA.MultiANewArray(state, desc, dims) => Seq(new MultiANewArrayInsnNode(desc.name, dims.length), new InsnNode(POP))
        case SSA.PutStatic(_, src, cls, name, desc) => Seq(new FieldInsnNode(PUTSTATIC, cls.name, name, desc.internalName))
        case SSA.GetStatic(_, cls, name, desc) => Seq(new FieldInsnNode(GETSTATIC, cls.name, name, desc.internalName), new InsnNode(POP))
        case SSA.PutField(_, src, obj, owner, name, desc) => Seq(new FieldInsnNode(PUTFIELD, owner.name, name, desc.internalName))
        case SSA.GetField(_, obj, owner, name, desc) => Seq(new FieldInsnNode(GETFIELD, owner.name, name, desc.internalName), new InsnNode(POP))
        case SSA.PutArray(_, array, indexSrc, src) => Seq(new InsnNode(arrayStoreOp(src)))
        case SSA.GetArray(_, indexSrc, array, tpe) => Seq(new InsnNode(arrayLoadOp(tpe)), new InsnNode(POP))
        case SSA.MonitorEnter(indexSrc) => ???
        case SSA.MonitorExit(indexSrc) => ???
      }

      upstreams ++ current

    }
  }

  def newArrayOp(typeRef: JType) = {
    typeRef match {
      case JType.Prim.Z => new IntInsnNode(NEWARRAY, T_BOOLEAN)
      case JType.Prim.C => new IntInsnNode(NEWARRAY, T_CHAR)
      case JType.Prim.B => new IntInsnNode(NEWARRAY, T_BYTE)
      case JType.Prim.S => new IntInsnNode(NEWARRAY, T_SHORT)
      case JType.Prim.I => new IntInsnNode(NEWARRAY, T_INT)
      case JType.Prim.F => new IntInsnNode(NEWARRAY, T_FLOAT)
      case JType.Prim.D => new IntInsnNode(NEWARRAY, T_DOUBLE)
      case JType.Prim.J => new IntInsnNode(NEWARRAY, T_LONG)
      case t => new TypeInsnNode(ANEWARRAY, t.name)
    }
  }

  def arrayStoreOp(src: SSA.Val) = {
    src.jtype match {
      case JType.Prim.Z => IASTORE
      case JType.Prim.C => CASTORE
      case JType.Prim.B => BASTORE
      case JType.Prim.S => SASTORE
      case JType.Prim.I => IASTORE
      case JType.Prim.F => FASTORE
      case JType.Prim.D => DASTORE
      case JType.Prim.J => LASTORE
      case t => AASTORE
    }
  }

  def arrayLoadOp(tpe: JType) = {
    tpe match {
      case JType.Prim.Z => IALOAD
      case JType.Prim.C => CALOAD
      case JType.Prim.B => BALOAD
      case JType.Prim.S => SALOAD
      case JType.Prim.I => IALOAD
      case JType.Prim.F => FALOAD
      case JType.Prim.D => DALOAD
      case JType.Prim.J => LALOAD
      case t => AALOAD
    }
  }

  def loadOp(ssa: SSA.Val) = {
    ssa.jtype match {
      case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => ILOAD
      case JType.Prim.J => LLOAD
      case JType.Prim.F => FLOAD
      case JType.Prim.D => DLOAD
      case _ => ALOAD
    }
  }

  def saveOp(n: SSA.Val) = {
    n.jtype match {
      case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => ISTORE
      case JType.Prim.J => LSTORE
      case JType.Prim.F => FSTORE
      case JType.Prim.D => DSTORE
      case _ => ASTORE
    }
  }

  def returnOp(a: SSA.Val) = {
    a.jtype match {
      case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => IRETURN
      case JType.Prim.J => LRETURN
      case JType.Prim.F => FRETURN
      case JType.Prim.D => DRETURN
      case _ => ARETURN
    }
  }
}
