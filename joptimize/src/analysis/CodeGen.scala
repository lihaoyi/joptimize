package joptimize.analysis

import java.util

import joptimize.Util
import joptimize.model.JType
//import joptimize.analysis.Renderer.sortVerticesForPrinting
import joptimize.graph.{HavlakLoopTree, LengauerTarjanDominatorTree, TarjansStronglyConnectedComponents}
import joptimize.model.{Program, SSA}
import org.objectweb.asm.Opcodes._
import org.objectweb.asm.tree._

import collection.JavaConverters._
import scala.collection.mutable

/**
  * Converts the hybrid dataflow/controlflow graph generated by the Walker
  * back into executable bytecode, without all the unreachable, unused or
  * constant-folded instructions
  */

object CodeGen{
  def apply(program: Program, mapping: Map[SSA.Node, String]): InsnList = {
    val controlFlowEdges = Util.findControlFlowGraph(program)
    val allBlocks = controlFlowEdges
      .flatMap{case (k, v) => Seq(k, v)}
      .collect{case b: SSA.Block => b}

    val blockEdges = controlFlowEdges.flatMap{
      case (k: SSA.Block, v: SSA.Jump) => Nil
      case (k: SSA.Jump, v: SSA.Block) => Seq(k.block -> v)
      case (k: SSA.Block, v: SSA.Block) => Seq(k -> v)
    }

    println(
      Renderer.renderGraph(
        controlFlowEdges,
        (lhs, rhs, indent) =>
          fansi.Color.Magenta(mapping(lhs)) ++
          " <- " ++
          fansi.Str.join(rhs.flatMap(r => Seq[fansi.Str](", ", fansi.Color.Magenta(mapping(r)))).drop(1):_*)
      )
    )

    val loopTree = HavlakLoopTree.analyzeLoops(blockEdges, allBlocks)

    def rec(l: HavlakLoopTree.Loop[SSA.Block], depth: Int, label0: List[Int]): Unit = {
      val indent = "    " * depth
      val id = label0.reverseIterator.map("-" + _).mkString
      val reducible = if (l.isReducible) "" else " (Irreducible)"
      val header = mapping(l.primaryHeader)
      val blockStr = l.basicBlocks.filter(_ != l.primaryHeader).map(x => mapping(x)).mkString("[", ", ", "]")
      println(s"${indent}loop$id$reducible, header: $header, blocks: $blockStr")

      for((c, i) <- l.children.zipWithIndex)rec(c, depth + 1, i :: label0)
    }

    rec(loopTree, 0, Nil)

    val (immediateDominators, dominatorDepth) = findDominators(blockEdges, allBlocks)

    RegisterAllocator.apply(program, immediateDominators)

    val nodesToBlocks = schedule(
      program, loopTree,
      dominatorDepth, immediateDominators,
      controlFlowEdges, mapping
    )

    val (finalOrderingMap, saveable, savedLocals) = Util.findSaveable(program, nodesToBlocks)
    val blocksToNodes = nodesToBlocks.groupBy(_._2).map{case (k, v) => (k, v.keys)}
    val (stringified, mapping2) = Renderer.renderSSA(program, nodesToBlocks)
//    pprint.log(nodesToBlocks.mapValues(mapping2))

    println()
    println(stringified)
    println()

    val cfg = Util.findControlFlowGraph(program)
    val allVertices = cfg.flatMap{case (a, b) => Seq(a, b)}
    val predecessor = cfg.groupBy(_._2).map{case (k, v) => (k, v.map(_._1))}
    val startNode = allVertices.find(!predecessor.contains(_)).get
    val successor = cfg.groupBy(_._1).map{case (k, v) => (k, v.map(_._2))}
    val sortedControls = mutable.LinkedHashSet.empty[SSA.Control]
    def sortBlocks(block: SSA.Control): Unit = if (!sortedControls(block)){
      sortedControls.add(block)
      for(s <- successor.getOrElse(block, Nil)) sortBlocks(s)
    }

    sortBlocks(startNode)

    val blockIndices = sortedControls.zipWithIndex.toMap

    val output = new InsnList()
    val labels = sortedControls.map(_ -> new LabelNode()).toMap
    val savedLocalNumbers = savedLocals.map{case (k, v) => (k, v._1)}.toMap
    val blockCode = mutable.Buffer.empty[(Seq[AbstractInsnNode], Option[AbstractInsnNode])]
    for(control <- sortedControls){
//      pprint.log(block)
      val insns = mutable.Buffer.empty[AbstractInsnNode]
      insns.append(labels(control))
      control match{
        case _: SSA.Jump =>
          val code = generateBytecode(
            control,
            savedLocalNumbers,
            jumpLabel = { srcBlock =>
              labels(
                srcBlock.downstreamList.collect{case t: SSA.True => t}.head
              )
            },
            fallthroughLabel = {srcBlock =>
              val destination = srcBlock.downstreamList.collect{case t: SSA.False => t}.head
              if (blockIndices(destination) == blockIndices(control) + 1) None
              else Some(labels(destination))
            },
            false
          )

          insns.appendAll(code)
        case block: SSA.Block =>
          val blockNodes = blocksToNodes.getOrElse(block, Nil).toSeq.sortBy(finalOrderingMap)
          for(node <- blockNodes if savedLocals.contains(node) && !node.isInstanceOf[SSA.Arg]){
            //        pprint.log(node)
            val nodeInsns = generateBytecode(
              node,
              savedLocalNumbers,
              _ => ???,
              _ => ???,
              node.downstreamList.exists(blockNodes.contains)
            )
            insns.appendAll(nodeInsns)
          }
      }



      val downstreamBlocks = control.downstreamList.collect{case b: SSA.Control => b}

      val footer = downstreamBlocks.toSeq match{
        case Seq(d) if blockIndices(d) != blockIndices(control) + 1 => Some(new JumpInsnNode(GOTO, labels(d)))
        case _ => None
      }

      blockCode.append(insns -> footer)
    }

    savedLocals.keysIterator.foreach{
      case phi: SSA.Phi =>
        for((k, v) <- phi.incoming){
          val (insns, footer) = blockCode(blockIndices(k))
          blockCode(blockIndices(k)) = (
            insns ++
            Seq(
              new VarInsnNode(ILOAD, savedLocalNumbers(v)),
              new VarInsnNode(ISTORE, savedLocalNumbers(phi))
            ),
            footer
          )

        }
      case _ => //do nothing
    }


    for((insns, footer) <- blockCode){
      insns.foreach(output.add)
      footer.foreach(output.add)
    }

    println()
    for((insns, footer) <- blockCode){
      for(insn <- insns ++ footer) println(Renderer.renderInsns(output, insn))
      println()
    }

    output
  }

  def schedule(program: Program,
               loopTree: HavlakLoopTree.Loop[SSA.Block],
               dominatorDepth: Map[SSA.Block, Int],
               immediateDominator: Map[SSA.Block, SSA.Block],
               graph: Seq[(SSA.Control, SSA.Control)],
               mapping: Map[SSA.Node, String]): Map[SSA.Val, SSA.Block] = {
    val (allVertices, _, _) =
      Util.breadthFirstAggregation[SSA.Node](program.allTerminals.toSet)(_.upstream)

    val loopNestMap = mutable.LinkedHashMap.empty[SSA.Node, Int]
    def recLoop(loop: HavlakLoopTree.Loop[SSA.Block], depth: Int): Unit = {
      loop.basicBlocks.foreach(loopNestMap(_) = depth)
      loop.children.foreach(recLoop(_, depth + 1))
    }

    recLoop(loopTree, 0)

    val scheduler = new ClickScheduler(dominatorDepth, immediateDominator, mapping) {
      override def downstream(ssa: SSA.Node) = ssa.downstreamList.toSeq

      override def upstream(ssa: SSA.Node) = ssa.upstream.collect{case ssa: SSA.Val => ssa}

      override def isPinned(ssa: SSA.Node) = ssa.isInstanceOf[SSA.Control]

      override def loopNest(block: SSA.Node) = {
        assert(block != null)
        loopNestMap(block)
      }
    }

    val startBlock = (graph.map(_._1).toSet -- graph.map(_._2)).head.asInstanceOf[SSA.Block]
    allVertices.collect{
      case c: SSA.Phi => scheduler.block(c) = c.block
      case c: SSA.Val if c.upstream.isEmpty => scheduler.block(c) = startBlock
    }

    allVertices.collect{
      case scheduleRoot: SSA.Phi => scheduler.scheduleEarlyRoot(scheduleRoot)
      case scheduleRoot: SSA.Control => scheduler.scheduleEarlyRoot(scheduleRoot)
    }

//    pprint.log(scheduler.block.map{case (k, v) => (k, mapping(v))}, height=9999)

    allVertices.collect{
      case scheduleRoot: SSA.Phi => scheduler.scheduleLateRoot(scheduleRoot)
      case scheduleRoot: SSA.Control => scheduler.scheduleLateRoot(scheduleRoot)
    }

//    pprint.log(scheduler.block.map{case (k, v) => (k, mapping(v))}, height=9999)

//    ???
    scheduler.block.filter{case (k, v) => v != null}.toMap
  }

  def findDominators[T](edges: Seq[(T, T)], allNodes0: Seq[T]): (Map[T, T], Map[T, Int]) = {
    val allNodes = allNodes0.distinct
    val indices = allNodes.zipWithIndex.toMap
    val nodes = indices.map(_.swap)

    val successorMap = edges.groupBy(_._1).map{case (k, v) => (indices(k), v.map(_._2).map(indices))}
    val predecessorMap = edges.groupBy(_._2).map{case (k, v) => (indices(k), v.map(_._1).map(indices))}

    val immediateDominators = new LengauerTarjanDominatorTree {
      def successors(v: Int) = successorMap.getOrElse(v, Nil)
      def predecessors(v: Int) = predecessorMap.getOrElse(v, Nil)
      def numNodes = indices.size
    }.computeDominatorTree()

    val dominatorDepth = {
      Array.tabulate(immediateDominators.length) { i =>
        var current = i
        var n = 0
        while (immediateDominators(current) != -1){
          current = immediateDominators(current)
          n += 1
        }
        n
      }
    }

    (
      immediateDominators.zipWithIndex.collect{case (v, i) if v != -1 => (nodes(i), nodes(v))}.toMap,
      dominatorDepth.zipWithIndex.map{case (v, i) => (nodes(i), v)}.toMap
    )
  }
  def generateBytecode(ssa: SSA.Node,
                       savedLocals: Map[SSA.Val, Int],
                       jumpLabel: SSA.Control => LabelNode,
                       fallthroughLabel: SSA.Control => Option[LabelNode],
                       usedInBlock: Boolean) = {
    def rec(ssa: SSA.Val): Seq[AbstractInsnNode] = {
      if (savedLocals.contains(ssa)){
        Seq(
          new VarInsnNode(
            ssa.jtype match{
              case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => ILOAD
              case JType.Prim.J => LLOAD
              case JType.Prim.F => FLOAD
              case JType.Prim.D => DLOAD
              case _ => ALOAD
            },
            savedLocals(ssa)
          )
        )
      }else compute(ssa)
    }

    def compute(ssa: SSA.Node): Seq[AbstractInsnNode] =
      if (ssa.isInstanceOf[SSA.Phi]) Nil
      else {
        val upstreams = ssa.upstream.collect{case n: SSA.Val => n}.flatMap(rec)
        val current: Seq[AbstractInsnNode] = ssa match{
          case r: SSA.Merge => Nil
          case n: SSA.Copy => Nil
          case n @ SSA.UnaBranch(block, a, opcode) =>
            val goto = fallthroughLabel(n).map(new JumpInsnNode(GOTO, _))
            val jump = Seq(new JumpInsnNode(opcode.i, jumpLabel(n)))
            jump ++ goto

          case n @ SSA.BinBranch(block, a, b, opcode) =>
            val goto = fallthroughLabel(n).map(new JumpInsnNode(GOTO, _))
            val jump = Seq(new JumpInsnNode(opcode.i, jumpLabel(n)))
            jump ++ goto
          case _: SSA.True => Nil
          case _: SSA.False => Nil
          case SSA.ReturnVal(block, a) =>
            Seq(new InsnNode(
              a.jtype match{
                case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => IRETURN
                case JType.Prim.J => LRETURN
                case JType.Prim.F => FRETURN
                case JType.Prim.D => DRETURN
                case _ => ARETURN
              }
            ))

          case SSA.Return(block) => Seq(new InsnNode(RETURN))
          case SSA.AThrow(_, src) => Seq(new InsnNode(ATHROW))
          case SSA.TableSwitch(_, src, min, max) => ???
          case SSA.LookupSwitch(_, src, keys) => ???

          case _: SSA.Phi => Nil
          case SSA.Arg(index, typeSize) => Nil
          case SSA.BinOp(a, b, opcode) => Seq(new InsnNode(opcode.i))
          case SSA.UnaOp(a, opcode) => Seq(new InsnNode(opcode.i))
          case SSA.CheckCast(src, desc) => ???
          case SSA.ArrayLength(src) => ???
          case SSA.InstanceOf(src, desc) => ???
          case SSA.PushI(value) => Seq(value match{
            case -1 => new InsnNode(ICONST_M1)
            case 0 => new InsnNode(ICONST_0)
            case 1 => new InsnNode(ICONST_1)
            case 2 => new InsnNode(ICONST_2)
            case 3 => new InsnNode(ICONST_3)
            case 4 => new InsnNode(ICONST_4)
            case 5 => new InsnNode(ICONST_5)
            case _ =>
              if (-128 <= value && value < 127) new IntInsnNode(BIPUSH, value)
              else if (-32768 <= value && value <= 32767) new IntInsnNode(BIPUSH, value)
              else new LdcInsnNode(value)
          })
          case SSA.PushJ(value) => Seq(value match{
            case 0 => new InsnNode(LCONST_0)
            case 1 => new InsnNode(LCONST_1)
            case _ => new LdcInsnNode(value)
          })
          case SSA.PushF(value) => Seq(value match{
            case 0 => new InsnNode(FCONST_0)
            case 1 => new InsnNode(FCONST_1)
            case 2 => new InsnNode(FCONST_2)
            case _ => new LdcInsnNode(value)
          })
          case SSA.PushD(value) => Seq(value match{
            case 0 => new InsnNode(DCONST_0)
            case 1 => new InsnNode(DCONST_1)
            case _ => new LdcInsnNode(value)
          })
          case SSA.PushS(value) => Seq(new LdcInsnNode(value))
          case SSA.PushNull() => Seq(new InsnNode(ACONST_NULL))
          case SSA.PushCls(value) =>
            Seq(new LdcInsnNode(org.objectweb.asm.Type.getType(value.name)))
          case SSA.InvokeStatic(srcs, cls, name, desc) =>
            Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
          case SSA.InvokeSpecial(srcs, cls, name, desc) =>
            Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
          case SSA.InvokeVirtual(srcs, cls, name, desc) =>
            Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
          case SSA.InvokeDynamic(name, desc, bsTag, bsOwner, bsName, bsDesc, bsArgs) => ???
          case SSA.New(cls) => ???
          case SSA.NewArray(src, typeRef) => ???
          case SSA.MultiANewArray(desc, dims) => ???
          case SSA.PutStatic(src, cls, name, desc) => ???
          case SSA.GetStatic(cls, name, desc) => ???
          case SSA.PutField(src, obj, owner, name, desc) => ???
          case SSA.GetField(obj, owner, name, desc) => ???
          case SSA.PutArray(src, indexSrc, array) => ???
          case SSA.GetArray(indexSrc, array, typeSize) => ???
          case SSA.MonitorEnter(indexSrc) => ???
          case SSA.MonitorExit(indexSrc) => ???
        }

        val save = ssa match{
          case n: SSA.Val if savedLocals.contains(n) =>
  //          val n = savedLocals(n)
            pprint.log(n)
            val dup = if (usedInBlock) Seq(new InsnNode(DUP)) else Nil
            pprint.log(dup)
            dup ++ Seq(
              new VarInsnNode(
                n.jtype match{
                  case JType.Prim.I | JType.Prim.S | JType.Prim.Z | JType.Prim.B | JType.Prim.C => ISTORE
                  case JType.Prim.J => LSTORE
                  case JType.Prim.F => FSTORE
                  case JType.Prim.D => DSTORE
                  case _ => ASTORE
                },
                savedLocals(n)
              )
            )
          case _ => Nil
        }

        upstreams ++ current ++ save

      }

    compute(ssa)
  }
}
