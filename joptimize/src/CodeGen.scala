package joptimize

import java.util

import org.objectweb.asm.Opcodes._
import org.objectweb.asm.tree._

import collection.JavaConverters._
import scala.collection.mutable

/**
  * Converts the hybrid dataflow/controlflow graph generated by the Walker
  * back into executable bytecode, without all the unreachable, unused or
  * constant-folded instructions
  */
object CodeGen {

  def apply(allVisitedBlocks: Seq[Walker.BlockResult],
            merges: Seq[(Frame[SSA], Frame[SSA])],
            initialArgs: Seq[SSA.Arg],
            inferredTypes: util.IdentityHashMap[SSA, IType]): (InsnList, Set[Int]) = {
    val allTerminals = allVisitedBlocks.flatMap(_.terminalInsns)
    val subCallArgLiveness = allVisitedBlocks.flatMap(_.subCallArgLiveness).toMap
    val mergeLookup = mutable.Map.empty[SSA, mutable.Buffer[SSA]]

    for((lhs, rhs) <- merges){
      lhs.zipForeach(rhs){(l, r) =>
        mergeLookup.getOrElseUpdate(l, mutable.Buffer()) += r
      }
    }

    val (allVertices, roots, downstreamEdges) =
      Util.breadthFirstAggregation[SSA](allTerminals.toSet){ ssa =>
        ssa.upstream ++ mergeLookup.getOrElse(ssa, Nil)
      }

    val saveable = downstreamEdges
      .groupBy(_._1)
      .map{
        case (k: SSA.PushI, _) => (k, false)
        case (k: SSA.PushJ, _) => (k, false)
        case (k: SSA.PushF, _) => (k, false)
        case (k: SSA.PushD, _) => (k, false)
        case (k: SSA.PushS, _) => (k, false)
        case (k: SSA.PushNull, _) => (k, false)
        case (k: SSA.PushCls, _) => (k, false)
        case (k, x) =>
          val n = x.distinct.size
          (k, n > 1 || n == 1 && allTerminals.contains(k))
      }

    val liveArgumentIndices = for{
      (a, i) <- initialArgs.zipWithIndex
      if roots(a)
    } yield i


    val savedLocals = new util.IdentityHashMap[SSA, Int]()
    for((a, i) <- initialArgs.zipWithIndex){
      savedLocals.put(a, i)
    }
    val startLabels = allVisitedBlocks.map(_.blockInsns -> new LabelNode()).toMap

    val blockInsns: Seq[Seq[AbstractInsnNode]] = for((block, blockIndex) <- allVisitedBlocks.zipWithIndex) yield {
      def rec(ssa: SSA): Seq[AbstractInsnNode] = {
        if (savedLocals.containsKey(ssa)){
          Seq(
            new VarInsnNode(
              inferredTypes.get(ssa).widen match{
                case JType.Prim.I => ILOAD
                case JType.Prim.J => LLOAD
                case JType.Prim.F => FLOAD
                case JType.Prim.D => DLOAD
                case _ => ALOAD
              },
              savedLocals.get(ssa)
            )
          )
        }else{
          val upstreams = ssa.upstream.flatMap(rec)
          val current: Seq[AbstractInsnNode] = ssa match{
            case SSA.Arg(index, typeSize) => ??? // shouldn't happen
            case SSA.BinOp(a, b, opcode) => Seq(new InsnNode(opcode.i))
            case SSA.UnaryOp(a, opcode) => Seq(new InsnNode(opcode.i))
            case SSA.UnaryBranch(a, target, opcode) =>
              Seq(new JumpInsnNode(opcode.i, startLabels(target)))
            case SSA.BinBranch(a, b, target, opcode) =>
              Seq(new JumpInsnNode(opcode.i, startLabels(target)))
            case SSA.ReturnVal(a) =>
              Seq(new InsnNode(
                inferredTypes.get(a).widen match{
                  case JType.Prim.I | JType.Prim.B | JType.Prim.S | JType.Prim.C => IRETURN
                  case JType.Prim.J => LRETURN
                  case JType.Prim.F => FRETURN
                  case JType.Prim.D => DRETURN
                  case _ => ARETURN
                }
              ))

            case SSA.Return() => Seq(new InsnNode(RETURN))
            case SSA.AThrow(src) => Seq(new InsnNode(ATHROW))
            case SSA.TableSwitch(src, min, max, default, targets) => ???
            case SSA.LookupSwitch(src, default, keys, targets) => ???
            case SSA.Goto(target) => ???
            case SSA.CheckCast(src, desc) => ???
            case SSA.ArrayLength(src) => ???
            case SSA.InstanceOf(src, desc) => ???
            case SSA.PushI(value) => Seq(value match{
              case -1 => new InsnNode(ICONST_M1)
              case 0 => new InsnNode(ICONST_0)
              case 1 => new InsnNode(ICONST_1)
              case 2 => new InsnNode(ICONST_2)
              case 3 => new InsnNode(ICONST_3)
              case 4 => new InsnNode(ICONST_4)
              case 5 => new InsnNode(ICONST_5)
              case _ => new LdcInsnNode(value)
            })
            case SSA.PushJ(value) => Seq(value match{
              case 0 => new InsnNode(LCONST_0)
              case 1 => new InsnNode(LCONST_1)
              case _ => new LdcInsnNode(value)
            })
            case SSA.PushF(value) => Seq(value match{
              case 0 => new InsnNode(FCONST_0)
              case 1 => new InsnNode(FCONST_1)
              case 2 => new InsnNode(FCONST_2)
              case _ => new LdcInsnNode(value)
            })
            case SSA.PushD(value) => Seq(value match{
              case 0 => new InsnNode(DCONST_0)
              case 1 => new InsnNode(DCONST_1)
              case _ => new LdcInsnNode(value)
            })
            case SSA.PushS(value) => Seq(new LdcInsnNode(value))
            case SSA.PushNull() => Seq(new InsnNode(ACONST_NULL))
            case SSA.PushCls(value) =>
              Seq(new LdcInsnNode(org.objectweb.asm.Type.getType(value.name)))
            case SSA.InvokeStatic(state, srcs, cls, name, desc) =>
              srcs.flatMap(rec) ++
              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
            case SSA.InvokeSpecial(state, srcs, cls, name, desc) =>
              srcs.flatMap(rec) ++
              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
            case SSA.InvokeVirtual(state, srcs, cls, name, desc) =>
              srcs.flatMap(rec) ++
              Seq(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
            case SSA.InvokeDynamic(name, desc, bsTag, bsOwner, bsName, bsDesc, bsArgs) => ???
            case SSA.New(cls) => ???
            case SSA.NewArray(src, typeRef) => ???
            case SSA.MultiANewArray(desc, dims) => ???
            case SSA.PutStatic(state, src, cls, name, desc) => ???
            case SSA.GetStatic(state, cls, name, desc) => ???
            case SSA.PutField(state, src, obj, owner, name, desc) => ???
            case SSA.GetField(state, obj, owner, name, desc) => ???
            case SSA.PutArray(state, src, indexSrc, array) => ???
            case SSA.GetArray(state, indexSrc, array, typeSize) => ???
            case SSA.MonitorEnter(indexSrc) => ???
            case SSA.MonitorExit(indexSrc) => ???
          }
          val save =
            if (!saveable.getOrElse(ssa, false)) Nil
            else {
              val n = savedLocals.size()
              val res = Seq(
                new InsnNode(DUP),
                new VarInsnNode(
                  inferredTypes.get(ssa).widen match{
                    case JType.Prim.I => ISTORE
                    case JType.Prim.J => LSTORE
                    case JType.Prim.F => FSTORE
                    case JType.Prim.D => DSTORE
                    case _ => ASTORE
                  },
                  n
                )
              )
              savedLocals.put(ssa, n)
              res
            }

          upstreams ++ current ++ save
        }
      }

      val renderRoots = block.blockInsns.value.filter(i => block.terminalInsns.contains(i) || saveable.getOrElse(i, false))
      Seq(startLabels(block.blockInsns)) ++ renderRoots.flatMap(rec)
    }
    val outputInsns = new InsnList()
    blockInsns.flatten.foreach(outputInsns.add)

    (outputInsns, liveArgumentIndices.toSet)
  }
}


