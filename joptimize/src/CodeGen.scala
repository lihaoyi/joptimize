package joptimize

import java.util

import org.objectweb.asm.Opcodes._
import org.objectweb.asm.tree._

import collection.JavaConverters._
import scala.collection.mutable

/**
  * Converts the hybrid dataflow/controlflow graph generated by the Walker
  * back into executable bytecode, without all the unreachable, unused or
  * constant-folded instructions
  */
object CodeGen {

  def apply(allVisitedBlocks: Seq[Walker.BlockResult],
            merges: Seq[(Frame[SSA], Frame[SSA])],
            initialArgs: Seq[SSA.Arg],
            inferredTypes: util.IdentityHashMap[SSA, IType]): (InsnList, Set[Int]) = {
    val allTerminals = allVisitedBlocks.flatMap(_.terminalInsns)
    val subCallArgLiveness = allVisitedBlocks.flatMap(_.subCallArgLiveness).toMap
    val mergeLookup = mutable.Map.empty[SSA, mutable.Buffer[SSA]]

    for((lhs, rhs) <- merges){
      lhs.zipForeach(rhs){(l, r) =>
        mergeLookup.getOrElseUpdate(l, mutable.Buffer()) += r
      }
    }

    val (allVertices, roots, downstreamEdges) =
      Util.breadthFirstAggregation[SSA](allTerminals.toSet){ ssa =>
        ssa.upstream ++ mergeLookup.getOrElse(ssa, Nil)
      }
    
    val saveable = downstreamEdges
      .groupBy(_._1)
      .mapValues(_.distinct.size)
      .map{case (k, x) => (k, x > 1 || x == 1 && allTerminals.contains(k)) }
      .toMap

    val liveArgumentIndices = for{
      (a, i) <- initialArgs.zipWithIndex
      if roots(a)
    } yield i

    val outputInsns = new InsnList()
    val savedLocals = new util.IdentityHashMap[SSA, Int]()
    for((a, i) <- initialArgs.zipWithIndex){
      savedLocals.put(a, i)
    }
    val startLabels = allVisitedBlocks.map(_.blockInsns -> new LabelNode()).toMap
    for(block <- allVisitedBlocks) {
      pprint.log(block.terminalInsns)
      outputInsns.add(startLabels(block.blockInsns))
      def rec(ssa: SSA): Unit = {
        ssa.upstream.foreach(rec)
        if (savedLocals.containsKey(ssa)){
          outputInsns.add(
            new VarInsnNode(
              inferredTypes.get(ssa).widen match{
                case JType.Prim.I => ILOAD
                case JType.Prim.J => LLOAD
                case JType.Prim.F => FLOAD
                case JType.Prim.D => DLOAD
                case _ => ALOAD
              },
              savedLocals.get(ssa)
            )
          )
        }else{
          ssa match{
            case SSA.Arg(index, typeSize) => ??? // shouldn't happen
            case SSA.BinOp(a, b, opcode) => outputInsns.add(new InsnNode(opcode.i))
            case SSA.UnaryOp(a, opcode) =>
            case SSA.Inc(a, increment) =>
            case SSA.UnaryBranch(a, target, opcode) =>
            case SSA.BinBranch(a, b, target, opcode) =>
              rec(a)
              rec(b)
              outputInsns.add(new JumpInsnNode(opcode.i, startLabels(target)))
            case SSA.ReturnVal(a) =>
              outputInsns.add(new InsnNode(
                inferredTypes.get(a).widen match{
                  case JType.Prim.I | JType.Prim.B | JType.Prim.S | JType.Prim.C => IRETURN
                  case JType.Prim.J => LRETURN
                  case JType.Prim.F => FRETURN
                  case JType.Prim.D => DRETURN
                  case _ => ARETURN
                }
              ))

            case SSA.Return() => outputInsns.add(new InsnNode(RETURN))
            case SSA.AThrow(src) => outputInsns.add(new InsnNode(ATHROW))
            case SSA.TableSwitch(src, min, max, default, targets) =>
            case SSA.LookupSwitch(src, default, keys, targets) =>
            case SSA.Goto(target) =>
            case SSA.CheckCast(src, desc) =>
            case SSA.ArrayLength(src) =>
            case SSA.InstanceOf(src, desc) =>
            case SSA.PushI(value) => outputInsns.add(value match{
              case -1 => new InsnNode(ICONST_M1)
              case 0 => new InsnNode(ICONST_0)
              case 1 => new InsnNode(ICONST_1)
              case 2 => new InsnNode(ICONST_2)
              case 3 => new InsnNode(ICONST_3)
              case 4 => new InsnNode(ICONST_4)
              case 5 => new InsnNode(ICONST_5)
              case _ => new LdcInsnNode(value)
            })
            case SSA.PushJ(value) => outputInsns.add(value match{
              case 0 => new InsnNode(LCONST_0)
              case 1 => new InsnNode(LCONST_1)
              case _ => new LdcInsnNode(value)
            })
            case SSA.PushF(value) => outputInsns.add(value match{
              case 0 => new InsnNode(FCONST_0)
              case 1 => new InsnNode(FCONST_1)
              case 2 => new InsnNode(FCONST_2)
              case _ => new LdcInsnNode(value)
            })
            case SSA.PushD(value) => outputInsns.add(value match{
              case 0 => new InsnNode(DCONST_0)
              case 1 => new InsnNode(DCONST_1)
              case _ => new LdcInsnNode(value)
            })
            case SSA.PushS(value) => outputInsns.add(new LdcInsnNode(value))
            case SSA.PushNull() => outputInsns.add(new InsnNode(ACONST_NULL))
            case SSA.PushCls(value) =>
              outputInsns.add(new LdcInsnNode(org.objectweb.asm.Type.getType(value.name)))
            case SSA.InvokeStatic(state, srcs, cls, name, desc) =>
              srcs.foreach(rec)
              outputInsns.add(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
            case SSA.InvokeSpecial(state, srcs, cls, name, desc) =>
              srcs.foreach(rec)
              outputInsns.add(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
            case SSA.InvokeVirtual(state, srcs, cls, name, desc) =>
              srcs.foreach(rec)
              outputInsns.add(new MethodInsnNode(INVOKESTATIC, cls.name, name, desc.unparse))
            case SSA.InvokeDynamic(name, desc, bsTag, bsOwner, bsName, bsDesc, bsArgs) =>
            case SSA.New(cls) =>
            case SSA.NewArray(src, typeRef) =>
            case SSA.MultiANewArray(desc, dims) =>
            case SSA.PutStatic(state, src, cls, name, desc) =>
            case SSA.GetStatic(state, cls, name, desc) =>
            case SSA.PutField(state, src, obj, owner, name, desc) =>
            case SSA.GetField(state, obj, owner, name, desc) =>
            case SSA.PutArray(state, src, indexSrc, array) =>
            case SSA.GetArray(state, indexSrc, array, typeSize) =>
            case SSA.MonitorEnter(indexSrc) =>
            case SSA.MonitorExit(indexSrc) =>
          }
          if (saveable.getOrElse(ssa, false)){
            val n = savedLocals.size()
            outputInsns.add(new InsnNode(DUP))
            outputInsns.add(
              new VarInsnNode(
                inferredTypes.get(ssa).widen match{
                  case JType.Prim.I => ISTORE
                  case JType.Prim.J => LSTORE
                  case JType.Prim.F => FSTORE
                  case JType.Prim.D => DSTORE
                  case _ => ASTORE
                },
                n
              )
            )
            savedLocals.put(ssa, n)
          }
        }
      }
      block.terminalInsns.reverseIterator.foreach(rec)
    }

    pprint.log(outputInsns.iterator().asScala.map(Util.prettyprint).toSeq)

    (outputInsns, liveArgumentIndices.toSet)
  }
}


